<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zy"><title>zy的博客</title><meta name="description" content="A simple and beautiful blog"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">zy的博客</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a href="https://github.com/Lhcfl" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li><li><a href="https://zhihu.com/people/jin-xin-4-68" target="_blank" rel="noopener"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> zy</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/07/11/lian-biao-zhuan-ti/">链表专题</a></h3></div><div class="post-content"><div class="card"><p><h1 id="链表算法专题"><a href="#链表算法专题" class="headerlink" title="链表算法专题"></a>链表算法专题</h1><p>有关链表的题目，有一个常用的技巧：在头结点之前再建立一个虚拟结点，让虚拟结点指向头结点。</p>
<pre class=" language-c++"><code class="language-c++">ListNode* dummyHead = new ListNode(-1);
dummyHead->next = head;</code></pre>
<h3 id="leetcode19"><a href="#leetcode19" class="headerlink" title="leetcode19"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leetcode19</a></h3><pre class=" language-c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode();
        dummyHead->next = head;
        ListNode* p = dummyHead;
        ListNode* q = head;
        while (n--) {
            q = q->next;
        }
        while (q) {
            p = p->next;
            q = q->next;
        }
        p->next = p->next->next;
        return dummyHead->next;
    }
};</code></pre>
<h3 id="leetcode237"><a href="#leetcode237" class="headerlink" title="leetcode237"></a><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">leetcode237</a></h3><p>把当前结点伪装成下一个结点，再把下一个点删掉。</p>
<pre class=" language-c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* tmp = node->next;
        node->val = tmp->val;
        node->next = tmp->next;
    }
};</code></pre>
<h3 id="leetcode83"><a href="#leetcode83" class="headerlink" title="leetcode83"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode83</a></h3><pre class=" language-c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;
        ListNode* cur = head;
        while (cur) {
            while (cur->next && cur->val == cur->next->val) {
                cur->next = cur->next->next;
            }
            cur = cur->next;
        }
        return dummyHead->next;
    }
};</code></pre>
<h3 id="leetcode61"><a href="#leetcode61" class="headerlink" title="leetcode61"></a><a href="https://leetcode.cn/problems/rotate-list/" target="_blank" rel="noopener">leetcode61</a></h3><pre class=" language-c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == NULL) {
            return NULL;
        }
        int n = 0;
        for (auto cnt = head; cnt; cnt = cnt->next) {
            n++;
        }
        auto p = head, q = head;
        k %= n;
        while (k--) {
            q = q->next;
        }
        while (q->next) {
            p = p->next;
            q = q->next;
        }
        q->next = head;
        head = p->next;
        p->next = NULL;
        return head;
    }
};</code></pre>
<h3 id="leetcode24"><a href="#leetcode24" class="headerlink" title="leetcode24"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">leetcode24</a></h3><p>本题为两两交换相邻的结点，可设虚拟头结点<code>dummyHead</code>，指针<code>p</code>指向<code>dummyHead</code>，指针<code>a</code>和<code>b</code>分别指向<code>p-&gt;next</code>和<code>p-&gt;next-&gt;next</code>，代码顺序为：</p>
<pre class=" language-c++"><code class="language-c++">/**
* p->dummyHead;
* a = p->next;
* b = p->next->next
*/
p->next = b;
a->next = b->next;
b->next = a;</code></pre>
<pre class=" language-c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;

        for (auto p = dummyHead; p->next && p->next->next; ) {
            auto a = p->next, b = p->next->next;
            p->next = b;
            a->next = b->next;
            b->next = a;
            p = a;
        }

        return dummyHead->next;
    }
};</code></pre>
<h3 id="leetcode206"><a href="#leetcode206" class="headerlink" title="leetcode206"></a><a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode206</a></h3><pre class=" language-c++"><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* p = NULL, *q = head;
        while (q) {
            ListNode* tmp = q->next;
            q->next = p;
            p = q;
            q = tmp;
        }
        return p;
    }
};</code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-07-11</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/算法/" title="算法">算法 </a><span class="leancloud_visitors"></span><span>About 562 words, 1 min 52 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/05/03/hua-dong-chuang-kou-wen-ti/">滑动窗口问题</a></h3></div><div class="post-content"><div class="card"><p><h1 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h1><p>数组操作中有一个重要的方法：<strong>滑动窗口</strong>。</p>
<p>所谓滑动窗口，就是<strong>不断调节子序列的起始位置和终止位置，从而得到我们想要的结果</strong>。</p>
<p>在算法题中的应用场景：</p>
<p><strong>关键词</strong>：</p>
<p>满足xxx条件（计算结果，出现次数，同时包含）</p>
<p>最长/最短</p>
<p>子串/子数组/子序列</p>
<p>例如：长度最小的子数组</p>
<h2 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h2><p><strong>寻找最长</strong>：</p>
<p><strong>核心</strong>：双指针<code>left</code>和<code>right</code>都在起始点，<code>right</code>向右逐位开始滑动循环。在每次滑动过程中：</p>
<ul>
<li>如果窗口内元素满足条件，<code>right</code>向右扩大窗口，并更新最优结果</li>
<li>如果窗口内元素不满足条件，<code>left</code>向右缩小窗口</li>
</ul>
<p><code>right</code>到达结尾。</p>
<p><strong>寻找最短</strong>：</p>
<p><strong>核心</strong>：双指针<code>left</code>和<code>right</code>都在起始点，<code>right</code>向右逐位开始滑动循环。在每次滑动过程中：</p>
<ul>
<li>如果窗口内元素满足条件，<code>left</code>向右缩小窗口，并更新最优结果</li>
<li>如果窗口内元素不满足条件，<code>right</code>向右扩大窗口</li>
</ul>
<p><code>right</code>到达结尾。</p>
<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p><strong>寻找最长</strong>：</p>
<pre><code>初始化left, result, bestResult
for(int right = 0; right &lt; num.length; right++) {
    窗口扩大，加入right对应元素，更新当前result
    while (result不满足要求) {
        窗口缩小，移除left对应元素，left右移
    }
    更新最优结果bestResult
}
return bestResult;</code></pre><p><strong>寻找最短</strong>：</p>
<pre><code>初始化left, result, bestResult
for (int right = 0; right &lt; nums.length; right++) {
    窗口扩大，加入right对应元素，更新当前result
    while (result满足要求) {
        更新最优结果bestResult
        窗口缩小，移除left对应元素，left右移
    }
}
return bestResult;</code></pre><h2 id="leetcode209"><a href="#leetcode209" class="headerlink" title="leetcode209"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">leetcode209</a></h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                result <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考自：</p>
<p><a href="https://programmercarl.com/" target="_blank" rel="noopener">代码随想录</a></p>
<p><a href="https://www.bilibili.com/video/BV1V44y1s7zJ?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener">红桃A士视频</a></p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-05-03</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/算法/" title="算法">算法 </a><span class="leancloud_visitors"></span><span>About 519 words, 1 min 43 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/04/29/er-fen-cha-zhao/">二分查找</a></h3></div><div class="post-content"><div class="card"><p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="二分的两段性"><a href="#二分的两段性" class="headerlink" title="二分的两段性"></a>二分的两段性</h2><p><img src="https://s2.loli.net/2022/04/30/QFaeP9xmARoWUX5.png" alt="二分.png"></p>
<p>注：</p>
<p>设计一个check函数，</p>
<ul>
<li>如果函数的性质满足绿色部分，不满足红色部分，使用模板一。</li>
<li>如果函数的性质满足红色部分，不满足绿色部分，使用模板二。</li>
</ul>
<p>模板一：</p>
<pre class=" language-c++"><code class="language-c++">int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}</code></pre>
<p>模板二：</p>
<pre class=" language-c++"><code class="language-c++">int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}</code></pre>
<h2 id="二分的流程"><a href="#二分的流程" class="headerlink" title="二分的流程"></a>二分的流程</h2><ol>
<li>确定二分边界</li>
<li>编写代码框架</li>
<li><strong>设计一个check（性质）</strong>  设计完的check函数，答案一定要在性质的边界</li>
<li>判断区间如何更新</li>
<li>如果更新方式写的是<code>l = mid</code>, <code>r = mid - 1</code>，那么就在算<code>mid</code>的时候加上1（即模板2）</li>
</ol>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="leetcode69"><a href="#leetcode69" class="headerlink" title="leetcode69"></a><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">leetcode69</a></h3><p>显而易见这里要求向下取整，check函数为：<code>t² &lt;= x</code>，</p>
<ul>
<li><p>在<code>根号t</code>左边，即红色部分满足这个性质</p>
</li>
<li><p>在<code>根号t</code>右边，即绿色部分不满足这个性质，</p>
</li>
</ul>
<p>故使用模板二。</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x;
        while (l < r) {
            int mid = l + (long long)r + 1 >> 1;
            if (mid <= x / mid) {   //等价于mid * mid <= x，防止溢出
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }
};</code></pre>
<h3 id="leetcode35"><a href="#leetcode35" class="headerlink" title="leetcode35"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">leetcode35</a></h3><p>这里check函数使用向上取整，即满足绿色部分，不满足红色部分，使用模板一。</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {

        // 边界条件
        if(nums.empty() || nums.back() < target) {
            return nums.size();
        }

        int l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
};</code></pre>
<h3 id="leetcode34"><a href="#leetcode34" class="headerlink" title="leetcode34"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">leetcode34</a></h3><pre class=" language-c++"><code class="language-c++">class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.empty()) {
            return {-1, -1};
        }

        int start, end;
        int l = 0, r = nums.size() - 1;

        // 起始位置：大于等于target的第一个数 
        // check():nums[mid] >= target  绿色部分满足，红色不满足  模板一
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (nums[l] != target) {
            return {-1, -1};
        } else {
            start = l;
        }

        l = 0, r = nums.size() - 1;

        // 终止位置：小于等于target的最后一个数
        // check():nums[mid] <= target 红色部分满足，绿色不满足  模板二
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (nums[mid] <= target) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        if (nums[l] != target) {
            return {-1, -1};
        } else {
            end = l;
        }

        return {start, end};
    }
};</code></pre>
<h3 id="leetcode74"><a href="#leetcode74" class="headerlink" title="leetcode74"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">leetcode74</a></h3><p>公式：把二维数组的编号<code>k</code>变成<code>(i, j)</code>的形式：</p>
<p><code>matrix[k / n] [k % n]</code>  n为二维数组的列数。</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) {
            return false;
        }
        int m = matrix.size(), n = matrix[0].size();
        int l = 0, r = m * n - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (matrix[mid / n][mid % n] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (matrix[l / n][l % n] == target) {
            return true;
        } else {
            return false;
        }
    }
};</code></pre>
<h3 id="leetcode153"><a href="#leetcode153" class="headerlink" title="leetcode153"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">leetcode153</a></h3><p>该题旋转数组把数组分为两段。</p>
<p>设计的check函数满足绿色而不满足红色，且答案恰好在端点处。</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int findMin(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] <= nums.back()) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return nums[l];
    }
};</code></pre>
<h3 id="leetcode33"><a href="#leetcode33" class="headerlink" title="leetcode33"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">leetcode33</a></h3><p>对于这类旋转数组，可以先找出最小值的点，进而找出两段有序数组。</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;

        // 找到最小值
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] <= nums.back()) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }

        // 判断target在哪一段
        if (target <= nums.back()) {
            r = nums.size() - 1;
        } else {
            l = 0;
            r = r - 1;
        }

        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }

        if (nums[l] != target) {
            return -1;
        } else {
            return l;
        }
    }
};</code></pre>
<h3 id="leetcode278"><a href="#leetcode278" class="headerlink" title="leetcode278"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">leetcode278</a></h3><p>满足是坏版本的第一个数，模板一。</p>
<pre class=" language-c++"><code class="language-c++">// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int l = 1, r = n;
        while (l < r) {
            int mid = l + (long long)r >> 1;
            if (isBadVersion(mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
};</code></pre>
<h3 id="leetcode162（该题不适用模板）"><a href="#leetcode162（该题不适用模板）" class="headerlink" title="leetcode162（该题不适用模板）"></a><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">leetcode162</a>（该题不适用模板）</h3><pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] > nums[mid + 1]) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
};</code></pre>
<h3 id="leetcode287（该题不适用模板）"><a href="#leetcode287（该题不适用模板）" class="headerlink" title="leetcode287（该题不适用模板）"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/" target="_blank" rel="noopener">leetcode287</a>（该题不适用模板）</h3><p>本题可根据抽屉原理做。有<code>n + 1</code>个苹果但只有<code>n</code>个抽屉，那么把抽屉分为两部分：<code>(l, mid)</code>和<code>(mid + 1, r)</code>，必定会有一边苹果的个数<strong>大于</strong>抽屉的个数。</p>
<p>同样的，把数组从中间一分为二，则必定有一边所包含元素的个数<strong>大于</strong>这一边区间的长度。</p>
<pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size() - 1;
        int l = 1, r = n;
        while (l < r) {
            int mid = l + r >> 1;
            // 统计左边元素个数
            int cnt = 0;
            for (auto i : nums) {
                if (i >= l && i <= mid) {
                    cnt++;
                }
            }
            //如果左边“苹果”个数大于“抽屉”个数，则答案在左边
            if (cnt > mid - l + 1) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
};</code></pre>
<h3 id="leetcode275"><a href="#leetcode275" class="headerlink" title="leetcode275"></a><a href="https://leetcode.cn/problems/h-index-ii/" target="_blank" rel="noopener">leetcode275</a></h3><pre class=" language-c++"><code class="language-c++">class Solution {
public:
    int hIndex(vector<int>& citations) {
        int l = 0, r = citations.size();
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (citations[citations.size() - mid] >= mid) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }
};</code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-04-29</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/算法/" title="算法">算法 </a><span class="leancloud_visitors"></span><span>About 1150 words, 3 min 50 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/01/15/flood-fill-suan-fa/">Flood Fill算法</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Flood-Fill算法"><a href="#Flood-Fill算法" class="headerlink" title="Flood Fill算法"></a>Flood Fill算法</h1><p>Flood Fill算法又叫洪水填充算法，一般用于图像处理。用于题目上的话一般就是海上的陆地一类的题目。</p>
<p>这里以<a href="https://www.acwing.com/problem/content/1115/" target="_blank" rel="noopener">本题</a>为例对Flood Fill算法进行讲解。</p>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。</p>
<p>你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。</p>
<p>请写一个程序，计算你总共能够到达多少块黑色的瓷砖。</p>
<blockquote>
<p>输入格式</p>
</blockquote>
<p>输入包括多个数据集合。</p>
<p>每个数据集合的第一行是两个整数 WW 和 HH，分别表示 xx 方向和 yy 方向瓷砖的数量。</p>
<p>在接下来的 HH 行中，每行包括 WW 个字符。每个字符表示一块瓷砖的颜色，规则如下</p>
<p>1）‘.’：黑色的瓷砖；<br>2）‘#’：红色的瓷砖；<br>3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。</p>
<p>当在一行中读入的是两个零时，表示输入结束。</p>
<blockquote>
<p>输出格式</p>
</blockquote>
<p>对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。</p>
<blockquote>
<p>数据范围</p>
</blockquote>
<p>1≤W,H≤201≤W,H≤20</p>
<blockquote>
<p>输入样例：</p>
</blockquote>
<pre><code>6 9 
....#. 
.....# 
...... 
...... 
...... 
...... 
...... 
#@...# 
.#..#. 
0 0</code></pre><blockquote>
<p>输出样例：</p>
</blockquote>
<pre><code>45</code></pre><hr>
<p>本题我们采用DFS写法，具体流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20210115171134.png" alt="By zy"></p>
<p>伪代码：</p>
<pre class=" language-c++"><code class="language-c++">int dfs(int x, int y) {
    标记此位置为已走过的点
    枚举四个偏移量
    if(邻格可走) {
        dfs(邻格坐标);
    }
}</code></pre>
<hr>
<p>代码实现：</p>
<pre class=" language-C++"><code class="language-C++">#include <iostream>

using namespace std;

const int N = 25;
int m, n;
int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
char arr[N][N];


int dfs(int x, int y) {
    arr[x][y] = '#';
    int res = 1;
    for(int i = 0; i < 4; i++) {
        int a = x + dx[i];
        int b = y + dy[i];
        if(a >= 0 && a < n && b >= 0 && b < m && arr[a][b] == '.') {
            res += dfs(a, b);
        }
    }
    return res;
}

int main() {
    while(cin >> m >> n, n || m) {
        for(int i = 0; i < n; i++) {
            cin >> arr[i];
        }
        int x, y;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(arr[i][j] == '@') {
                    x = i;
                    y = j;
                }
            }
        }
        cout << dfs(x, y) << endl;
    }
    return 0;
}</code></pre>
<p>这题还是用到了偏移法，即<code>dx[] = {-1, 0, 1, 0}</code>和<code>dy[] = {0, 1, 0, -1}</code>，这两个偏移数组可以记住，顺序是上、右、下、左。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-01-15</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/算法/" title="算法">算法 </a><span class="leancloud_visitors"></span><span>About 603 words, 2 min 0 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/12/01/tan-tan-min-gan-ci-guo-lu-de-shi-xian/">谈谈敏感词过滤的实现</a></h3></div><div class="post-content"><div class="card"><p><h1 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h1><p>最近在做一个项目的过程中正好遇到了敏感词过滤这一功能，由于这个功能应用广泛，就记录下来以便日后复习。</p>
<p>设计敏感词过滤可以通过Trie树来实现，即我们所说的前缀树/字典树。</p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie树也称为前缀树、字典树，最大的特点就是共享<strong>字符串的公共前缀</strong>来达到节省空间的目的了。</p>
<p>Trie树的<strong>根节点</strong>不存任何数据，每<strong>整个</strong>个分支代表一个完整的字符串。</p>
<p><font color="red"><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong></font>。</p>
<p>举个简单的例子来说明一下。</p>
<p>我们有 6 个字符串，它们分别是：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 6 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p>
<p>这个时候，我们就可以先对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。最后构造出来的就是下面这个图中的样子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201202172248.jpg" alt=""></p>
<blockquote>
<p>Trie树的应用</p>
</blockquote>
<p>Trie树最大的特点就是利用了字符串的公共前缀，当我们在搜索框输入关键词时，搜索框会自动帮我们列举出相关结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201201211554.png" alt=""></p>
<p>在设计敏感词过滤的过程中，我们可以这样定义Trie树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201201211249.png" alt=""></p>
<p>图中的红叉表示标记到这个字符，从<code>root</code>到此字符所经过的字符串是敏感词。</p>
<p>把所有敏感词存入Trie树中，设置三个指针：p1、p2、p3。</p>
<p>其中：p1指向Trie树的根节点，p2和p3指向待过滤的字符数组。</p>
<h2 id="过滤过程"><a href="#过滤过程" class="headerlink" title="过滤过程"></a>过滤过程</h2><p>过滤过程为：</p>
<ul>
<li><p>p1找root下一层有没有与p2指向相同的字符，若没有，p2和p3都向后移动；若有，p1指向那个字符对应的节点，p2不动，p3向后移动，然后重复上述过程。</p>
</li>
<li><p>如果p1指向了带标记的节点，那么将p2到p3中间的字符串统一用过滤词如<code>***</code>代替并存入结果数组中，p2和p3都移动到 p3 + 1的位置；如果没有指向带标记的节点，p2++，p3 == p2。当p3 == 数组长度时，将剩余字符加入结果数组中。</p>
</li>
</ul>
<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词<strong>查找</strong>这个过程的时间复杂度是 <strong>O(n * m)</strong>。</p>
<p>如果有 t 个敏感词的话，<strong>构建</strong> trie 树的时间复杂度是 <strong>O(t * m)</strong>。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里构建Trie树我们使用HashMap实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SensitiveFilter</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>SensitiveFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String REPLACEMENT <span class="token operator">=</span> <span class="token string">"***"</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> TrieNode rootNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// 关键词结束标识</span>
        <span class="token keyword">private</span> <span class="token keyword">boolean</span> isKeywordEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> TrieNode<span class="token operator">></span> subNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isKeywordEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> isKeywordEnd<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setKeywordEnd</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> keywordEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            isKeywordEnd <span class="token operator">=</span> keywordEnd<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 添加子节点</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addSubNode</span><span class="token punctuation">(</span>Character c<span class="token punctuation">,</span> TrieNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            subNodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 获取子节点</span>
        <span class="token keyword">public</span> TrieNode <span class="token function">getSubNode</span><span class="token punctuation">(</span>Character c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> subNodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>
            InputStream is <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"sensitive-words.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String keyword<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keyword <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 添加到前缀树</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addKeyword</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"加载敏感词文件失败: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addKeyword</span><span class="token punctuation">(</span>String keyword<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TrieNode tmp <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keyword<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> c <span class="token operator">=</span> keyword<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            TrieNode subNode <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">getSubNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>subNode <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                subNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                tmp<span class="token punctuation">.</span><span class="token function">addSubNode</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> subNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            tmp <span class="token operator">=</span> subNode<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> keyword<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tmp<span class="token punctuation">.</span><span class="token function">setKeywordEnd</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token comment" spellcheck="true">/**
* 返回过滤后的文本
* */</span>
    <span class="token keyword">public</span> String <span class="token function">filter</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        TrieNode tmp <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>
        <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>position <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> c <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 忽略特殊符号</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isSymbol</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>tmp <span class="token operator">==</span> rootNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    begin<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                position<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">getSubNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tmp <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 以begin开头的字符串不是敏感词</span>
                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                begin<span class="token operator">++</span><span class="token punctuation">;</span>
                position <span class="token operator">=</span> begin<span class="token punctuation">;</span>
                tmp <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">isKeywordEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>REPLACEMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>
                position<span class="token operator">++</span><span class="token punctuation">;</span>
                begin <span class="token operator">=</span> position<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                position<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 将剩下的字符串加入结果中</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment" spellcheck="true">// 判断是否为符号</span>
    <span class="token comment" spellcheck="true">// 0x2E80 ~ 0x9FFF 是东亚文字范围</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSymbol</span><span class="token punctuation">(</span>Character c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>CharUtils<span class="token punctuation">.</span><span class="token function">isAsciiAlphanumeric</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0x2E80</span> <span class="token operator">||</span> c <span class="token operator">></span> <span class="token number">0x9FFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-01</span><a class="tag" href="/categories/项目/" title="项目">项目 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/项目/" title="项目">项目 </a><span class="leancloud_visitors"></span><span>About 1220 words, 4 min 4 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/10/30/dui-pai-xu/">堆排序</a></h3></div><div class="post-content"><div class="card"><p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote>
<p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为<strong>O(nlogn)</strong>，它也是<strong>不稳定排序</strong>。</p>
</blockquote>
<p>根据数组<strong>脑补</strong>出一颗完全二叉树：</p>
<p>对于数组中下标为<code>i</code>的节点：</p>
<p><strong>左孩子下标：2i + 1</strong></p>
<p><strong>右孩子下标：2i + 2</strong></p>
<p><strong>父节点：(i - 1) / 2</strong></p>
<p>务必牢记上述关系！</p>
<blockquote>
<p>什么是堆？</p>
</blockquote>
<p><strong>堆就是一棵完全二叉树。</strong></p>
<p><strong>大根堆</strong>：任何一棵子树的<strong>最大值</strong>都是这棵子树的头部。</p>
<p><strong>小根堆</strong>：任何一棵子树的<strong>最小值</strong>都是这棵子树的头部。</p>
<p>把一个数组转化成大根堆：</p>
<p>heapInsert方法：</p>
<p>从0开始逐步扩大范围，根据父节点下标 = (i - 1) / 2<strong>将当前值与父节点比较</strong>，如果比父节点大就和父节点交换，直到不比父节点大为止。<strong>关键：上浮</strong>。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>调整大根堆：</p>
<p>heapify方法：</p>
<p>如果大根堆中<strong>某一个位置元素值减小</strong>，则该元素和其左右孩子中较大的那个交换，重新调整为大根堆。<strong>关键：下沉</strong>。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> largest <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>
        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">=</span> largest<span class="token punctuation">;</span>
        left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>堆排序：</p>
<ul>
<li><p>将数组建立成大根堆</p>
</li>
<li><p>每次把堆顶元素都和大根堆的最后一个元素交换</p>
</li>
<li><p>heapSize - 1，执行heapify方法</p>
</li>
<li><p>循环至heapSize为0</p>
</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">heapSort</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 建立大根堆</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> heapSize <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>heapSize <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 将数组转化为大根堆的关键-----------上浮
     * */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 数组中若有数变小，调整大根堆-------下沉
     * 可用于弹出堆的一个元素：将堆中最后一个元素与堆顶元素交换，然后heapsize - 1，从0位置上开始执行此方法
     * */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> largest <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>
            largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            index <span class="token operator">=</span> largest<span class="token punctuation">;</span>
            left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">HeapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>关于堆排序，这里有个动图可以加深一下理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201030161331.gif" alt=""></p>
<p>堆结构非常重要</p>
<ul>
<li>堆结构的heapInsert和heapify</li>
<li>堆结构的增大和减少</li>
<li>如果只是建立堆的过程，时间复杂度为O(N)</li>
<li>优先级队列结构就是堆结构</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-30</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/算法/" title="算法">算法 </a><span class="leancloud_visitors"></span><span>About 747 words, 2 min 29 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/10/29/tcp-de-san-ci-wo-shou-yu-si-ci-hui-shou/">TCP的三次握手与四次挥手</a></h3></div><div class="post-content"><div class="card"><p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201029195451.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201029195452.png" alt=""></p>
<h3 id="TCP头部的报文结构"><a href="#TCP头部的报文结构" class="headerlink" title="TCP头部的报文结构"></a>TCP头部的报文结构</h3><p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201029195518.png" alt=""></p>
<ul>
<li><p>序号：<strong>seq序号</strong>，占32位，用来<strong>标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记</strong>。</p>
</li>
<li><p>确认号：<strong>ack序号</strong>，占32位，<strong>只有ACK标志位为1时，确认序号字段才有效，ack=seq+1</strong>。</p>
</li>
</ul>
<p><strong>序号</strong>是<strong>本TCP报文</strong>数据部分的首字节序号，<strong>确认号</strong>是成功接收<strong>别人的TCP报文</strong>，并期待接收的<strong>下一个TCP报文中数据部分的首字节的序号</strong>。</p>
<h3 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h3><ul>
<li>URG：紧急指针标志</li>
<li><font color="red"><strong>ACK：确认序号标志</strong></font></li>
<li>PSH：push标志</li>
<li>RST：重置连接标志</li>
<li><font color="red"><strong>SYN：同步序号，用于建立连接过程</strong></font></li>
<li><font color="red"><strong>FIN：finish标志，用于释放连接</strong></font></li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>不要将<strong>确认序号ack</strong>与<strong>标志位中的ACK</strong>搞混了。</li>
<li><strong>确认方ack = 发起方seq + 1</strong>，两端配对。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP是一种<strong>面向连接的、可靠的、基于字节流的传输层通信协议</strong>，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。<strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p>
<p>“握手”是为了建立连接，流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201029195538.png" alt=""></p>
<p>对于面试中的回答，可以这样说：</p>
<ul>
<li><p><strong>刚开始客户端处于 closed 状态，服务端处于 listen 状态</strong>。</p>
</li>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN(c)</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 <strong>ISN(s)</strong>，同时会把客户端的 <strong>ISN + 1 作为 ACK 的值</strong>，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>
</li>
<li><p>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了连接。</p>
</li>
</ul>
<p>对于seq和ack的值，个人有个不成熟的记忆方法：</p>
<p>即：</p>
<p>若上一段请求报文有seq0，本段请求报文的 ack1 = seq0 + 1。</p>
<p>若上一段请求报文有ack0，本段请求报文的 seq1 = ack0。</p>
<p>（1和0只是标记两段请求报文）</p>
<p><font color="red"><strong>千万不要用大白话回答！</strong></font></p>
<h3 id="TCP-三次握手异常情况实战分析"><a href="#TCP-三次握手异常情况实战分析" class="headerlink" title="TCP 三次握手异常情况实战分析"></a>TCP 三次握手异常情况实战分析</h3><blockquote>
<p>TCP 第一次握手 SYN 丢包</p>
</blockquote>
<p>当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 <code>tcp_syn_retries</code> 值后，客户端不再发送 SYN 包。</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201029195304.webp" alt="TCP第一次握手SYN 丢包"></p>
<blockquote>
<p>TCP 第二次握手 SYN、ACK 丢包</p>
</blockquote>
<ul>
<li>客户端发起 SYN 后，由于第二次握手 SYN、ACK 丢包，客户端是无法收到服务端的 SYN、ACK 包，当发生超时后，就会重传 SYN 包。</li>
<li>服务端收到客户的 SYN 包后，就会回 SYN、ACK 包，但是客户端一直没有回 ACK，服务端在超时后，重传了 SYN、ACK 包，<strong>接着一会，客户端超时重传的 SYN 包又抵达了服务端，服务端收到后，超时定时器就重新计时，然后回了 SYN、ACK 包，所以相当于服务端的超时定时器只触发了一次，又被重置了。</strong></li>
<li>最后，客户端 SYN 超时重传次数达到了 5 次（tcp_syn_retries 默认值 5 次），就不再继续发送 SYN 包了。</li>
</ul>
<p>所以，我们可以发现，<strong>当第二次握手的 SYN、ACK 丢包时，客户端会超时重发 SYN 包，服务端也会超时重传 SYN、ACK 包。</strong></p>
<p>简单地说：</p>
<p>当 TCP 第二次握手 SYN、ACK 包丢了后，<strong>客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。</strong></p>
<p>客户端 SYN 包超时重传的最大次数，是由 <strong>tcp_syn_retries</strong> 决定的，<strong>默认值是 5 次</strong>；服务端 SYN、ACK 包时重传的最大次数，是由 <strong>tcp_synack_retries</strong> 决定的，<strong>默认值是 5 次</strong>。</p>
<blockquote>
<p>TCP 第三次握手 ACK 丢包</p>
</blockquote>
<p>在建立 TCP 连接时，如果第三次握手的 ACK 服务端无法收到，则服务端就会短暂处于 <code>SYN_RECV</code> 状态，而客户端会处于 <code>ESTABLISHED</code> 状态。</p>
<p>由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 <code>tcp_synack_retries</code> 值（默认值 5 次）后，服务端就会断开 TCP 连接。</p>
<p>而客户端则会有两种情况：</p>
<ul>
<li>如果客户端没发送数据包，一直处于 <code>ESTABLISHED</code> 状态，然后经过较长一段时间才可以发现一个「死亡」连接，于是客户端连接就会断开连接。</li>
<li>如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 <code>tcp_retries2</code> 值（默认值 15 次）后，客户端就会断开 TCP 连接。</li>
</ul>
<h3 id="三次握手常见面试题"><a href="#三次握手常见面试题" class="headerlink" title="三次握手常见面试题"></a>三次握手常见面试题</h3><blockquote>
<p>三次握手有什么作用？</p>
</blockquote>
<ul>
<li>确认双方的接收能力、发送能力是否正常。</li>
<li>指定自己的初始化序列号，为后面的可靠传送做准备。</li>
<li>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。</li>
</ul>
<blockquote>
<p>（ISN）是固定的吗？</p>
</blockquote>
<p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<blockquote>
<p>什么是半连接队列？</p>
</blockquote>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，<strong>此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列</strong>。</p>
<p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>这里再补充一点关于SYN-ACK 重传次数的问题：</p>
<p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>
<p>注意，每次重传等待的时间不一定相同，一般会是<strong>指数增长</strong>，例如间隔时间为 1s，2s，4s，8s…</p>
</blockquote>
<blockquote>
<p>三次握手过程中可以携带数据吗？</p>
</blockquote>
<p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，<strong>第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了</strong>。</p>
<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，<strong>他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了</strong>，所以能携带数据页没啥毛病。</p>
<blockquote>
<p>首次握手有什么隐患？</p>
</blockquote>
<p>会出现SYN超时。</p>
<ul>
<li><p>服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认。</p>
</li>
<li><p>于是服务端不断重试直到超时，Linux默认等待63秒才断开连接。</p>
</li>
</ul>
<p><strong>防护措施：</strong></p>
<ul>
<li><p>SYN队列满后，通过 <code>tcp_syncookies</code>参数会发SYN cookie【源端口+目标端口+时间戳组成】。</p>
</li>
<li><p>若为正常连接则Client会回发SYN Cookie，直接建立连接。</p>
</li>
</ul>
<blockquote>
<p>建立连接，Client出现故障怎么办？</p>
</blockquote>
<p>利用<strong>保活机制</strong>：</p>
<ul>
<li>向对方发送保活探测报文，如果未收到响应则继续发送。</li>
<li>当尝试次数达到保活探测数仍然未收到响应则中断连接。</li>
</ul>
<blockquote>
<p>为什么一定要进行三次握手？两次不行吗？</p>
</blockquote>
<p>首先我们要弄明白三次握手的目的：</p>
<p><em>第一次握手</em>：客户端发包，服务端收到了。</p>
<p>这样服务端会得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
<p><em>第二次握手</em>：服务端发包，客户端收到了。</p>
<p>这样客户端会得出结论：客户端的发送、接收能力是正常的，服务端的发送、接收能力也是正常的。</p>
<p><strong>但是要注意，此时服务端并不能确认客户端的接受能力是否是正常的</strong>。</p>
<p>于是就有了<em>第三次握手</em>：客户端发包，服务端收到了。</p>
<p>这样服务端就能得出最终结论：客户端的发送、接收能力是正常的，服务端的发送、接收能力也是正常的。</p>
<p>如果用了两次握手，则有可能会发生下面这种情况：</p>
<blockquote>
<p>客户端向服务端发出一个连接请求，但由于某种原因该连接请求报文<strong>丢失</strong>了，于是客户端又向服务端发送了一个连接请求，这次一切正常，建立连接后进行数据传输，然后释放连接，<strong>注意：客户端一共发送了两个连接请求报文段，一个丢失，一个到达服务端。</strong>但如果丢失的那个请求在某个网络节点滞留了，延迟了一会才到达服务端，这时服务端就会误以为客户端又发送了一次新的连接请求，而<strong>由于只有两次握手，此时服务端只要发出确认就能够建立新的连接了</strong>。但此时客户端会忽略服务端发来的确认，不进行数据传输，那么服务端就会一直等待客户端发送数据，<strong>造成资源的浪费</strong>。</p>
</blockquote>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw?x-oss-process=image/format,png" alt=""></p>
<ul>
<li><p>第一次挥手：客户端发送一个FIN，用来关闭客户端和服务端的数据传送，<strong>客户端进入FIN_WAIT_1状态</strong>。</p>
</li>
<li><p>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号 ack = seq + 1，<strong>服务端进入CLOSE_WAIT状态</strong>。</p>
</li>
<li><p>第三次挥手：服务端发送一个FIN，用来关闭服务端和客户端的数据传送，<strong>服务端进入LAST_ACK状态</strong>。</p>
</li>
<li><p>第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号 ack = seq + 1，服务端进入CLOSED状态，完成四次挥手。</p>
<p>注意<strong>客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接</strong>。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以<strong>服务端结束TCP连接的时间要比客户端早一些</strong>。</p>
</li>
</ul>
<h3 id="四次挥手常见面试题"><a href="#四次挥手常见面试题" class="headerlink" title="四次挥手常见面试题"></a>四次挥手常见面试题</h3><blockquote>
<p>为什么挥手需要四次？</p>
</blockquote>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，<strong>仅仅表示客户端不再发送数据了但是还能接收数据</strong></li>
<li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次</li>
</ul>
<blockquote>
<p>为什么会有TIME_WAIT状态，且超过2MSL？</p>
</blockquote>
<p><strong>主动发起关闭连接的一方，才会有 TIME-WAIT 状态</strong>。</p>
<p>TIME-WAIT 作用：<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong></p>
<p>原因：</p>
<p>1.防止关闭后又建立的新连接接收到旧连接的数据包</p>
<ul>
<li><p>假设TIME_WAIT等待过短，那么被复用的端口可能会建立新的TCP连接</p>
</li>
<li><p>此时旧的连接在四次握手前可能有一个旧的数据包刚刚到达（图中SEQ=301）</p>
<ul>
<li><p><strong>这样新的连接就会处理旧的服务端数据包，产生数据错乱等严重问题</strong>。</p>
</li>
<li><p>经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20201029221050.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<p>2.<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong></p>
<ul>
<li>如果服务端发送了FIN后，没有接收到客户端的ACK报文，则会超时重传再次发送FIN。</li>
<li>所以需要客户端等待2MSL，确保服务端接收到了ACK报文。</li>
</ul>
<blockquote>
<p>服务器出现大量CLOSE_WAIT状态的原因？</p>
</blockquote>
<p>对方关闭socket连接，而我方忙于读或写，没有及时关闭连接。</p>
<p>解决措施：</p>
<ul>
<li>检查代码，特别是释放资源的代码。</li>
<li>检查配置，特别是处理请求的线程配置。</li>
</ul>
<p>看到这里，希望读者对于以下几个问题都有了答案。</p>
<ol>
<li>请画出三次握手和四次挥手的示意图</li>
<li>为什么连接的时候是三次握手？</li>
<li>什么是半连接队列？</li>
<li>ISN(Initial Sequence Number)是固定的吗？</li>
<li>三次握手过程中可以携带数据吗？</li>
<li>如果第三次握手丢失了，客户端服务端会如何处理？</li>
<li>SYN攻击是什么？</li>
<li>挥手为什么需要四次？</li>
<li>四次挥手释放连接时，等待2MSL的意义?</li>
</ol>
<p>参考资料：</p>
<ul>
<li><p><a href="https://coding.imooc.com/class/303.html" target="_blank" rel="noopener">剑指Java面试-Offer直通车</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/jTDU-zxP1INTYLpGLypjXQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jTDU-zxP1INTYLpGLypjXQ</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/63690137" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63690137</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86426969</a></p>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-29</span><a class="tag" href="/categories/计算机网络/" title="计算机网络">计算机网络 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/计算机网络/" title="计算机网络">计算机网络 </a><span class="leancloud_visitors"></span><span>About 4174 words, 13 min 54 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/10/03/tan-xin-suan-fa-xiang-guan-ti-mu/">贪心算法相关题目</a></h3></div><div class="post-content"><div class="card"><p><h1 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h1><table>
<thead>
<tr>
<th>题目名称</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></td>
<td>Medium</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></td>
<td>Medium</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></td>
<td>Easy</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></td>
<td>Medium</td>
</tr>
</tbody></table>
<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<hr>
<p>思路：此题使用<strong>双指针碰撞</strong>和<strong>贪心思想</strong>，总是贪心先固定容器的宽度。根据木桶原理（盛水的高度由最短的那块木板决定），<strong>高的那块木板往里面走，只可能让盛水越来越少，但是短板往里面走，却有可能让盛水越来越多</strong>。</p>
<p>我认为写的比较好的题解是<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/" target="_blank" rel="noopener">这篇</a>。</p>
<p>代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> length <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> area <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p>
<hr>
<p>思路：题目要<em>找到需要移除区间的最小数量，使剩余区间互不重叠</em>，我们可以理解为找到最多的无重叠区间。</p>
<p><strong>对于贪心算法中的区间问题，我们通常会考虑将区间按照右端点进行一个排序。</strong>此题也是如此，每个区间的结尾很重要，结尾越小，则后面越有可能容纳更多的区间。</p>
<p>代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">eraseOverlapIntervals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> length <span class="token operator">=</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>a <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                end <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a>455. 分发饼干</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/assign-cookies/</a></p>
<hr>
<p>思路：对于一个孩子来说，如果小的饼干可以满足，我们就没必要用更大的饼干，这样更大的就可以留给其他对饼干大小需求更大的孩子。另一方面，对饼干大小需求小的孩子更容易被满足，所以，我们可以<strong>从需求小的孩子开始分配饼干</strong>。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。</p>
<p>我们<strong>每次从剩下的孩子中，找出对饼干大小需求最小的，然后发给他剩下的饼干中能满足他的最小的饼干</strong>，这就是典型的贪心算法，而这样得到的分配方案，也就是满足的孩子个数最多的方案。</p>
<p>代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                res<span class="token operator">++</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
                j<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                j<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game/</a></p>
<hr>
<h4 id="从前向后"><a href="#从前向后" class="headerlink" title="从前向后"></a>从前向后</h4><ul>
<li><p>其实这题最好的解法不是 DP，而是贪婪算法 Greedy Algorithm。</p>
</li>
<li><p>因为我们并不关心每一个位置上的剩余步数，我们只希望知道能否到达末尾，也就是说我们只对最远能到达的位置感兴趣。</p>
</li>
<li><p>维护一个变量 <code>reach</code>，表示最远能到达的位置，初始化为 <code>0</code>。</p>
</li>
<li><p>遍历数组中每一个数字，如果当前坐标大于 <code>reach</code> 或者 <code>reach</code> 已经抵达最后一个位置则跳出循环，否则就更新 reach 的值为其和 <code>i + nums[i]</code> 中的较大值，其中 <code>i + nums[i]</code> 表示当前位置能到达的最大位置。</p>
</li>
</ul>
<p>解题思路：</p>
<ul>
<li><p>如果某一个作为起跳点的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为起跳点；</p>
</li>
<li><p>可以对每一个能作为起跳点的格子都尝试跳一次，把能跳到最远的距离不断更新；</p>
</li>
<li><p>如果可以一直跳到最后，就成功了。</p>
</li>
</ul>
<p>代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canJump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> maxReach <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> maxReach<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            maxReach <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxReach<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>参考：</p>
<ul>
<li><a href="https://www.yuque.com/liweiwei1419/algo/newasc" target="_blank" rel="noopener">https://www.yuque.com/liweiwei1419/algo/newasc</a></li>
<li><a href="https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/</a></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-03</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/算法/" title="算法">算法 </a><span class="leancloud_visitors"></span><span>About 1053 words, 3 min 30 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/10/02/leetcode-shua-ti-hui-zong-bu-zai-geng-xin/">LeetCode刷题汇总（不再更新）</a></h3></div><div class="post-content"><div class="card"><p><p>本篇是记录本人在刷leetcode过程中的题解及经验总结，望读者善用<code>Ctrl + F</code>。</p>
<h1 id="数组篇"><a href="#数组篇" class="headerlink" title="数组篇"></a>数组篇</h1><h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p>
<hr>
<p>解题核心思想：<strong>双指针</strong>。</p>
<p>注意本题目的数组是有序的，这就说明重复的元素必然相邻。</p>
<p>题目要求<strong>不使用额外空间</strong>删除重复项，那么就说明这一题我们可以把不重复的元素都挪到数组的左边，最后返回不重复元素的个数即可。</p>
<p>解法：</p>
<ul>
<li>定义一个指针 <code>p</code> 指向数组第一个元素，定义一个指针 <code>q</code> 指向数组的第二个元素；</li>
<li>比较 <code>nums[p]</code> 和 <code>nums[q]</code>：<ul>
<li>如果 <code>nums[p] == nums[q]</code> ：<code>q</code> 向后移动一位；</li>
<li>如果 <code>nums[p] != nums[q]</code>：把 <code>nums[q]</code> 的值赋给 <code>nums[p + 1]</code>，<code>p</code> 和 <code>q</code> 都向后移动一位；</li>
</ul>
</li>
<li>返回 <code>p + 1</code>。</li>
</ul>
<p>优化：</p>
<p>考虑如下数组：</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200730224028.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200730224028.png" alt="img"></a></p>
<p>此时数组中没有重复元素，按照上面的方法，每次比较时 <code>nums[p]</code> 都不等于 <code>nums[q]</code>，因此就会将 <code>q</code> 指向的元素原地复制一遍，这个操作其实是不必要的。</p>
<p>因此我们可以添加一个小判断，当 <code>q - p &gt; 1</code> 时，才进行复制。</p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">&lt;</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">-</span> p <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            nums<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    q<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     </code></pre>
<h1 id="二分查找篇"><a href="#二分查找篇" class="headerlink" title="二分查找篇"></a>二分查找篇</h1><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-rotated-sorted-array</a></p>
<hr>
<p>本题的难点在于我们并不知道这个数组旋转了几次，由传统的二分查找模板我们知道需要比较 <code>nums[mid]</code> 和 <code>target</code> 的值的大小来判断区间，但在此旋转数组中我们无法直接这样比较，因为<strong>二分查找的前提是数组有序</strong>。因此，我们需要讨论 <code>nums[mid]</code> 和 <code>target</code> 所处的区间位置。即：</p>
<p><strong>先根据 <code>nums[mid]</code> 与 <code>nums[low]</code> 的关系判断 <code>mid</code> 是在左段还是右段，接下来再判断 <code>target</code> 是在 <code>mid</code> 的左边还是右边，从而来调整左右边界 <code>low</code> 和 <code>high</code>。</strong></p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//说明 mid 在左段</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//说明 target 在左段</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a>搜索旋转排序数组 II</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii</a></p>
<hr>
<p>这一题在上一题的基础上添加了一个条件：有重复元素，我们只需要加上这段代码就行了：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    low<span class="token operator">++</span><span class="token punctuation">;</span>
    high<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                low<span class="token operator">++</span><span class="token punctuation">;</span>
                high<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">></span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p><strong>总结</strong>：</p>
<p>这一题难就难在我们无法直接判断区间，所以需要<strong>分段讨论 <code>nums[mid]</code> 和 <code>target</code> 所在的区间是左还是右</strong>。</p>
<hr>
<p>还有一个非常相似的题目：<a href="https://leetcode-cn.com/problems/search-rotate-array-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-rotate-array-lcci</a></p>
<p>这一题是在本题的基础上考虑了重复元素，要求返回重复元素的最小下标。由于本人精力有限，这题暂且先搁置一段时间。</p>
<h1 id="链表篇"><a href="#链表篇" class="headerlink" title="链表篇"></a>链表篇</h1><h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p>
<hr>
<p>本体的关键在于知道什么时候可以反转什么时候停止反转，并且链表的断开与重连要把握好。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode pre <span class="token operator">=</span> dummy<span class="token punctuation">,</span> end <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>end <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k <span class="token operator">&amp;&amp;</span> end <span class="token operator">!=</span> null<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                end <span class="token operator">=</span> end<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            ListNode tmp <span class="token operator">=</span> end<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            end<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
            ListNode start <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
            start<span class="token punctuation">.</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
            pre <span class="token operator">=</span> start<span class="token punctuation">;</span>
            end <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ListNode p <span class="token operator">=</span> null<span class="token punctuation">,</span> q <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ListNode tmp <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            q<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            p <span class="token operator">=</span> q<span class="token punctuation">;</span>
            q <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
<hr>
<p>对于这类两数相加问题，我们需要考虑进位和补零，在两个节点的value相加大于等于10时，我们就需要进位，当一个节点为空而另一个节点不为空时，我们就要对空节点的value值进行补零操作。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> x <span class="token operator">=</span> l1 <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">int</span> y <span class="token operator">=</span> l2 <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>
            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>其中，carry表示进位。</p>
<p>如果这道题能够理解，那么<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener"><strong>两数相加Ⅱ</strong></a>也就迎刃而解了。这道题主要是需要把链表翻转过来再进行上面那道题的操作，我们先来熟悉一下链表的反转：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> ListNode <span class="token function">reverse1</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>
    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ListNode tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>如果是还不太熟悉链表的反转，建议先去做一下这道题目：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></strong>。</p>
<p>下面是完整题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        ListNode r1 <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode r2 <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>r1 <span class="token operator">!=</span> null <span class="token operator">||</span> r2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> x <span class="token operator">=</span> r1 <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> r1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">int</span> y <span class="token operator">=</span> r2 <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> r2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>
            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>r1 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                r1 <span class="token operator">=</span> r1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>r2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                r2 <span class="token operator">=</span> r2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ListNode rr <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>dummy<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> rr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">private</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode l<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
        ListNode cur <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            ListNode tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于两数相加Ⅱ，我们还可以用<strong>栈</strong>来实现，这里推荐去看一下力扣的评论区，在此不再赘述。</p>
<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<hr>
<p>本题实在是经典，不得不拿出来说说了。</p>
<p>鉴于两次遍历大家都会，我就不在此细说了，想看详细解说可以去本题的讨论区逛一逛，本篇博客主要讲使用双指针一次遍历的解法。</p>
<p><strong>思路：</strong></p>
<p>提到删除，我们自然而然的就会想到找到要删除的节点的前一个节点，将它的指针域指向要删除节点的后一个节点，也就是 <code>p.next = p.next.next</code>，而这题也不例外，我们需要找到该节点的前一个节点。</p>
<p>我们可以设想假设设定了双指针 <code>p</code> 和 <code>q</code>的话，当 <code>q</code>指向末尾的 <code>null</code>，<code>p</code>与 <code>q</code> 之间相隔的元素个数为 <code>n</code>时，那么删除掉 <code>p</code> 的下一个指针就完成了要求。</p>
<p><strong>流程：</strong></p>
<ul>
<li>设置一个虚拟节点 <code>dummy</code> 指向 <code>head</code>；</li>
<li>定义两个指针 <code>p</code> 和 <code>q</code> 同时指向 <code>dummy</code>；</li>
<li>让指针 <code>q</code> 移动 <code>n + 1</code> 个位置，使 <code>p</code> 和 <code>q</code> 的间距（不包含两头）为 <code>n</code>；</li>
<li>再使 <code>q</code> 和 <code>p</code> 同时移动，直至 <code>q</code>为 <code>null</code> ，此时，<code>p</code> 正好指向要被删除的元素的前一个元素；</li>
<li>接下来该干什么就不用我说了吧？懂得都懂，芜湖，起飞！</li>
</ul>
<p>为了方便理解，在此，引用一下<a href="https://leetcode-cn.com/u/misterbooo/" target="_blank" rel="noopener">程序员吴师兄</a>精心制作的动图：</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200711224545.gif" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200711224545.gif" alt="img"></a></p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        ListNode q <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>length <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            length<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<hr>
<p>本题有两种解法，一种迭代，一种递归。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们可以用迭代的方法来实现上述算法。当 <code>l1</code> 和 <code>l2</code> 都不是空链表时，判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p>
<p>流程：</p>
<ul>
<li>先创建一个哑节点 <code>dummy</code>，定义一个指针 <code>pre</code> 指向 <code>dummy</code>；</li>
<li>比较两链表各节点的值 <code>val</code>，使 <code>pre</code> 和 <code>l1</code> or <code>l2</code> 同时向后移动一位；</li>
<li>到其中一个链表为空时，将另一个链表拼接至结果链表就行了。</li>
</ul>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null <span class="token operator">?</span> l2 <span class="token operator">:</span> l1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归解法我也不是很明白，就暂且把代码放上来，以后慢慢理解吧。</p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="反转部分链表"><a href="#反转部分链表" class="headerlink" title="反转部分链表"></a>反转部分链表</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a></p>
<hr>
<p>本题是反转链表的进阶版，不熟悉反转链表的可以看我的这篇<a href="https://blog.csdn.net/skdjq666/article/details/107369390" target="_blank" rel="noopener">博客</a>。</p>
<p>正如反转链表一样，这一题我们依然可以使用双指针来解决。</p>
<p>流程：</p>
<ul>
<li>定义一个哑节点 <code>dummy</code>；</li>
<li>定义两个指针 <code>p</code> 和 <code>q</code>，一前一后；</li>
<li>使指针 <code>q</code> 指向反转的起始位置，<code>p</code> 指向 <code>q</code> 的前一个节点；</li>
<li>将 <code>q</code> 后面的节点依次删除，并利用<strong>头插法</strong>插入到 <code>p</code> 指向节点的后面。</li>
</ul>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
        ListNode q <span class="token operator">=</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>length <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            length<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            ListNode tmp <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            q<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            tmp<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            p<span class="token punctuation">.</span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
<hr>
<p>本题有两种解法，一种是使用哈希表的暴力解法，还有一种是使用快慢指针的巧妙解法。</p>
<p>下面将着重介绍快慢指针解法。</p>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200713104806.gif" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200713104806.gif" alt="img"></a></p>
<p>根据上面的原理得出，<strong>如果一个链表存在环，那么快慢指针必然会相遇。</strong></p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
               <span class="token keyword">if</span><span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span><span class="token punctuation">{</span>
                fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>如果一个链表是环形链表，那么必然有若干个节点会被遍历多次。</p>
<blockquote>
<p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。</p>
<ol>
<li>如果当前结点为空结点 <code>null</code>（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。</li>
<li>如果当前结点的引用已经存在于哈希表中，那么返回 <code>true</code>（即该链表为环形链表）。</li>
</ol>
</blockquote>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> nodesSeen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodesSeen<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            nodesSeen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p><strong>总结</strong>：在环形链表问题上，使用快慢指针解法非常方便。</p>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>
<hr>
<p>这一题我采用的是</p>
<p>暴力解法1：</p>
<p>将链表转换为数组，然后利用双指针从数组的两端比较值是否相等。</p>
<p>2020/11/2更新：</p>
<p>暴力解法2：使用一个栈结构，将链表的每个节点放入栈中，然后将每个链表节点值与栈弹出的元素比较。</p>
<p>额外空间复杂度为O(1)的解法：</p>
<p>先用快慢指针定位到链表的中点，然后反转后半部分链表，两指针分别从头和尾移动，比较节点值。</p>
<p>最后不要忘记还原链表！</p>
<hr>
<p>暴力解法1题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode tmp <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>tmp <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> fast <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">&lt;</span> fast<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>fast<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            slow<span class="token operator">++</span><span class="token punctuation">;</span>
            fast<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>精妙解法：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ListNode n1 <span class="token operator">=</span> head<span class="token punctuation">;</span>
        ListNode n2 <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// find mid node</span>
            n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n1 -> mid</span>
            n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n2 -> end</span>
        <span class="token punctuation">}</span>
        n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n2 -> right part first node</span>
        n1<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mid.next -> null</span>
        ListNode n3 <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// right part convert</span>
            n3 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n3 -> save next node</span>
            n2<span class="token punctuation">.</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// next of right node convert</span>
            n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n1 move</span>
            n2 <span class="token operator">=</span> n3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n2 move</span>
        <span class="token punctuation">}</span>
        n3 <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n3 -> save last node</span>
        n2 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// n2 -> left first node</span>
        <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> n2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// check palindrome</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n1<span class="token punctuation">.</span>val <span class="token operator">!=</span> n2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// left to mid</span>
            n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// right to mid</span>
        <span class="token punctuation">}</span>
        n1 <span class="token operator">=</span> n3<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        n3<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// recover list</span>
            n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            n1<span class="token punctuation">.</span>next <span class="token operator">=</span> n3<span class="token punctuation">;</span>
            n3 <span class="token operator">=</span> n1<span class="token punctuation">;</span>
            n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>题目地址：</p>
<blockquote>
<ol>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/</a></li>
</ol>
</blockquote>
<p>这两题都是相交链表问题。</p>
<hr>
<p>本题仅用文字可能说不太明白，建议大家看<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/" target="_blank" rel="noopener">这里</a>的视频讲解。</p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>headA <span class="token operator">==</span> null <span class="token operator">||</span> headB <span class="token operator">==</span> null<span class="token punctuation">)</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        ListNode pA <span class="token operator">=</span> headA<span class="token punctuation">;</span>
        ListNode pB <span class="token operator">=</span> headB<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>pA <span class="token operator">!=</span> pB<span class="token punctuation">)</span><span class="token punctuation">{</span>
            pA <span class="token operator">=</span> <span class="token punctuation">(</span>pA <span class="token operator">==</span> null <span class="token operator">?</span> headB <span class="token operator">:</span> pA<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pB <span class="token operator">=</span> <span class="token punctuation">(</span>pB <span class="token operator">==</span> null <span class="token operator">?</span> headA <span class="token operator">:</span> pB<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> pA<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-list</a></p>
<hr>
<p>本题在面试中比较常考，应好好掌握。</p>
<p>思路：既然是每次将链表向右移动 k 个长度，那么我们可以联想到<strong>环</strong>，可以先把链表成环，然后再根据题目的要求从环的某一处断开不就可以了吗？</p>
<p>为了方便理解，在此我引用大佬<a href="https://leetcode-cn.com/u/liweiwei1419/" target="_blank" rel="noopener">liweiwei1419</a>的图：</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200730162510.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200730162510.png" alt="img"></a></p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> ListNode <span class="token function">rotateRight</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            length<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        k <span class="token operator">=</span> k <span class="token operator">%</span> length<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        ListNode newHead <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        fast<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p>小结：</p>
<ul>
<li>如果当前指针 <code>p</code> 在 <code>head</code> 节点上，且 <code>head</code> 节点的值是有效的，那么指针 <code>p</code> 只需要移动 <code>length - k - 1</code> 次就可以移动到链表的<strong>倒数第 k 个节点的前一个结点</strong>了。</li>
<li>判断链表长度可以用 <code>while</code> 循环：定义一个指针 <code>q</code> 在头节点，循环条件为 <code>q.next != null</code>。</li>
<li>向右旋转链表是从链表的倒数第 <code>k</code> 个节点前断环，向左旋转链表则是从链表的正数第 <code>k</code> 个节点后断环。</li>
</ul>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>题目地址：</p>
<p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></p>
<p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></p>
<hr>
<p>本题是复制一个带随机指针的链表，我们使用HashMap。</p>
<p>因为是复制链表，所以我们需要先复制每一个节点，由于HashMap可以存储任意类型的值，这里我们就可以想到使用HashMap来复制节点：</p>
<pre class=" language-java"><code class="language-java">HashMap<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> Node<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200926092011.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200926092011.png" alt="img"></a></p>
<p>复制完节点后，就需要复制指针，这里我们就需要用到 map 的 put 方法和 get 方法，具体如下图：</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200926092022.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200926092022.png" alt="img"></a></p>
<p>具体代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Node <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        HashMap<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> Node<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Node cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>random <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>random<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于复制指针，我们一定要注意<strong>不能</strong>写成这样：</p>
<pre class=" language-java"><code class="language-java">map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>random <span class="token operator">=</span> cur<span class="token punctuation">.</span>random<span class="token punctuation">;</span></code></pre>
<p><strong>这样是错误的！</strong>因为我们是要返回一个新的链表，如果是上面这种情况，新的链表就会指向旧的链表，从而出错！</p>
<h1 id="栈篇"><a href="#栈篇" class="headerlink" title="栈篇"></a>栈篇</h1><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a></p>
<hr>
<p>思路：</p>
<p>此题是栈的一个常见应用，即判断括号的有效性。根据栈后进先出的特性，我们可以将括号push进栈中，待需要对比时pop出来即可。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Character<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> c <span class="token operator">!=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="二叉树篇"><a href="#二叉树篇" class="headerlink" title="二叉树篇"></a>二叉树篇</h1><h2 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a>590. N叉树的后序遍历</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a></p>
<hr>
<p>思路：</p>
<p>后序遍历即根节点在最后，我们可以使用LinkedList的addFirst()方法每次都将元素插入链表的第一个节点中，这样最先插入的根节点就会移动到链表的最后去了。</p>
<p>使用 LinkedList 创建两个链表，初次判断根节点是否为空，如果为空，则返回空链表。如果不为空，将根节点插入链表2的第一个节点中，然后判断链表2是否为空，若不为空，将链表2中的唯一一个节点插入链表1的头一个节点中，遍历根节点的子节点，若不为空，插入链表2中，反复循环直至链表2为空。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
// Definition for a Node.
class Node {
    public int val;
    public List&lt;Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List&lt;Node> _children) {
        val = _val;
        children = _children;
    }
};
*/</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorder</span><span class="token punctuation">(</span>Node root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        LinkedList<span class="token operator">&lt;</span>Node<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            Node node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>Node child<span class="token operator">:</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span></code></pre>
<p>补充：</p>
<p>Java 集合 LinkedList <code>push()</code>和<code>pop()</code>方法</p>
<p><code>public void push(E e)</code>：将元素<strong>插入</strong>列表的<strong>前面</strong>。</p>
<p><code>public E pop()</code>：<strong>删除并返回</strong>列表的<strong>第一个元素</strong>。</p>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<hr>
<p>思路：</p>
<p>1.判断根节点是否为空——–空返回true<br>2.判断左右子树是否对称———对称就返回true<br>2.1.当左子树的左节点等于右子树的右节点，且左子树的右节点等于右子树的左节点时对称<br>3.<strong>递归终止条件</strong>：<br>3.1.左子树右子树均为null——–true<br>3.2.左子树右子树只有一个为null——–false<br>3.3.左子树的值不等于右子树的值——–false</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200612100942.gif" target="_blank" rel="noopener"><img src="https://skdjq.github.io/img/loading.gif" alt="递归流程图"></a></p>
<p>递归流程图</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">LR</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">LR</span><span class="token punctuation">(</span>TreeNode leftChild<span class="token punctuation">,</span>TreeNode rightChild<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>leftChild <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> rightChild <span class="token operator">==</span> null<span class="token punctuation">)</span>     
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>leftChild <span class="token operator">==</span> null <span class="token operator">||</span> rightChild <span class="token operator">==</span> null<span class="token punctuation">)</span>     
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>leftChild<span class="token punctuation">.</span>val <span class="token operator">!=</span> rightChild<span class="token punctuation">.</span>val<span class="token punctuation">)</span>     
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">LR</span><span class="token punctuation">(</span>leftChild<span class="token punctuation">.</span>left<span class="token punctuation">,</span>rightChild<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">LR</span><span class="token punctuation">(</span>leftChild<span class="token punctuation">.</span>right<span class="token punctuation">,</span>rightChild<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="面试题55-I-二叉树的深度"><a href="#面试题55-I-二叉树的深度" class="headerlink" title="面试题55 - I. 二叉树的深度"></a>面试题55 - I. 二叉树的深度</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a></p>
<hr>
<p>思路：本题可以使用递归的方法解决。二叉树的深度就是左右子树最大深度 + 1。</p>
<p>1.递归的终止条件：root为空。</p>
<p>2.递归工作： 本质上是对树做后序遍历。</p>
<ul>
<li>计算节点 root 的 左子树的深度 ，即调用 <code>maxDepth(root.left)</code></li>
<li>计算节点 root 的 右子树的深度 ，即调用 <code>maxDepth(root.right)</code></li>
</ul>
<p>3.返回值： 返回 此树的深度 ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code></p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>本题进阶：</p>
<h2 id="面试题55-II-平衡二叉树"><a href="#面试题55-II-平衡二叉树" class="headerlink" title="面试题55 - II. 平衡二叉树"></a>面试题55 - II. 平衡二叉树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a></p>
<hr>
<p>本题思路：</p>
<p><strong>后序遍历 + 剪枝 （从底至顶）</strong></p>
<blockquote>
<p>此方法为本题的最优解法，但剪枝的方法不易第一时间想到。</p>
</blockquote>
<p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<p>算法流程：</p>
<p><code>recur(root)</code> 函数：</p>
<p><strong>返回值：</strong></p>
<ul>
<li>当节点root 左 / 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值+1（ <code>max(left, right) + 1</code>）；</li>
<li>当节点root 左 / 右子树的深度差&gt;2 ：则返回−1，代表<strong>此子树不是平衡树</strong> 。</li>
</ul>
<p><strong>终止条件：</strong></p>
<ul>
<li>当 root 为空：说明越过叶节点，因此返回高度0 ；</li>
<li>当左（右）子树深度为−1 ：代表此树的左（右）子树 不是平衡树，因此剪枝，直接返回 −1 ；</li>
</ul>
<p><code>isBalanced(root)</code>函数：</p>
<p><strong>返回值</strong>： 若 <code>recur(root) != -1</code>，则说明此树平衡，返回true ； 否则返回false 。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">recur</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p>
<hr>
<p>本题是一道比较经典的题目，核心思想其实还是<strong>递归</strong>。（好像二叉树大多都是使用递归……）</p>
<p>我们知道前序遍历的第一个节点是根节点root，中序遍历root两边的分别是左子树和右子树，根据这一特性，我们就可以求解本题，下面给出某位大佬的解题思路（原地址请点击<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">这里</a>）：</p>
<p><em>题目分析：</em></p>
<blockquote>
<p>前序遍历特点： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序，以题目示例为例：[ 3 | 9 | 20 15 7 ]<br>中序遍历特点： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序，以题目示例为例：[ 9 | 3 | 15 20 7 ]<br>根据题目描述输入的前序遍历和中序遍历的结果中都不含重复的数字，其表明树中每个节点值都是唯一的。</p>
</blockquote>
<p>根据以上特点，可以按顺序完成以下工作：</p>
<ul>
<li>前序遍历的首个元素即为根节点 root 的值；</li>
<li>在中序遍历中搜索根节点 root 的索引 ，可将中序遍历划分为<code>[ 左子树 | 根节点 | 右子树 ]</code>。</li>
<li>根据中序遍历中的左（右）子树的节点数量，可将前序遍历划分为 <code>[ 根节点 | 左子树 | 右子树 ]</code>。</li>
</ul>
<p>自此可确定 三个节点的关系 ：1.<strong>树的根节点</strong>、2.<strong>左子树根节点</strong>、3.<strong>右子树根节点</strong>（即前序遍历中左（右）子树的首个元素）。</p>
<blockquote>
<p>子树特点： 子树的前序和中序遍历仍符合以上特点，以题目示例的右子树为例：前序遍历：[20 | 15 | 7]，中序遍历 [ 15 | 20 | 7 ] 。</p>
</blockquote>
<p>根据子树特点，我们可以通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。此递推性质让我们联想到用 递归方法 处理。<br><strong><em>递归解析：</em></strong></p>
<p><strong>递推参数：</strong> 前序遍历中根节点的索引<code>pre_root</code>、中序遍历左边界<code>in_left</code>、中序遍历右边界<code>in_right</code>。<br>终止条件： 当<code>in_left</code>&gt;<code>in_right</code>，子树中序遍历为空，说明已经越过叶子节点，此时返回 null 。<br>递推工作：<br>建立根节点<code>root</code>： 值为前序遍历中索引为<code>pre_root</code>的节点值。<br>搜索根节点<code>root</code>在中序遍历的索引<code>i</code>： 为了提升搜索效率，本题解使用哈希表 dic 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)。<br>构建根节点<code>root</code>的左子树和右子树： 通过调用 <code>recur()</code>方法开启下一层递归。<br>左子树： 根节点索引为<code>pre_root + 1</code> ，中序遍历的左右边界分别为<code>in_left</code> 和<code>i - 1</code>。<br>右子树： 根节点索引为<code>i - in_left + pre_root + 1</code>（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 <code>i + 1</code> 和<code>in_right</code>。<br>返回值： 返回 <code>root</code>，含义是当前递归层级建立的根节点 <code>root</code>为上一递归层级的根节点的左或右子节点。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">;</span>
    <span class="token keyword">public</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>preorder <span class="token operator">=</span> preorder<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    TreeNode <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> pre_root<span class="token punctuation">,</span> <span class="token keyword">int</span> in_left<span class="token punctuation">,</span> <span class="token keyword">int</span> in_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>in_left <span class="token operator">></span> in_right<span class="token punctuation">)</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>pre_root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>pre_root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>pre_root <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>in_left<span class="token punctuation">,</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>pre_root <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> in_left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>in_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>关于上面的<code>root.left</code>和<code>root.right</code>有些朋友可能不是很理解，这里给出解释：</p>
<p>root.left：</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200628122912.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200628122912.png" alt="img"></a></p>
<p>root.right：</p>
<p><a href="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200628122916.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/skdjq/PicgoImg/img/20200628122916.png" alt="img"></a></p>
<h2 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a>剑指 Offer 32 - I. 从上到下打印二叉树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p>
<hr>
<p>思路：</p>
<p>看到<strong>按层序遍历</strong>二叉树，我们就该想到<strong>广度优先搜索（BFS）</strong>，而一提到广度优先搜索，我们就可以想到用<strong>队列（Queue）</strong>来解决。</p>
<p>算法流程：</p>
<ul>
<li>特例处理：当根节点为空时，返回一个空数组<code>[]</code>；</li>
<li>初始化：创建一个临时的动态数组存放<code>val</code>值，再创建一个带有根节点的队列；</li>
<li>BFS循环：<ul>
<li>终止条件：队列为空</li>
<li>出队：将队首元素出队，记为<code>node</code></li>
<li>存值：将<code>node</code>的值存放在动态数组中</li>
<li>入队：若<code>node</code>的左右节点不为空，将<code>node</code>的左右节点加入到队列中（注意：由于队列是FIFO结构，题目要求从左到右打印，所以必须左节点先入队）</li>
</ul>
</li>
<li>将动态数组的值转移到结果数组<code>res</code>，返回<code>res</code>。</li>
</ul>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//直至队列为空时终止循环</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tmp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>   queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>  queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//将动态数组中的值转移给要返回的结果数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>tmp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p>
<hr>
<p>思路：</p>
<p>这一题与上一题只有很微小的差别，个人觉得这一题还比较难一些，然而它却是简单难度的题目😀。废话少说，我们开始这一题的解析：</p>
<p>这一题与上一题最大的不同就是我们需要把每一层单独打印出来，返回的结果是嵌套的List，然而思路是不会变的，我们依旧使用队列解决。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span>   queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//这里因为queue.size()是变化的，所以我们采用递减的方法</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                tmp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>   queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>  queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p>
<hr>
<p>思路：</p>
<p>本题目在上一题的基础上又增加了奇偶层打印次序的问题，我们可以使用一个双端队列，奇数层插入尾部，偶数层时插入头部。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//模拟双端队列</span>
            LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//这里res.size()初始为0，所以在打印第二层时res.size()为1，第三层时res.size()为2，依此类推</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    tmp<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                    tmp<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>   queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>  queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p>2020-12-12更新：</p>
<p>由于本题有的Oj要求返回<code>List&lt;&gt;</code>，有的Oj要求返回<code>ArrayList&lt;&gt;</code>，故上述方法适用性不强，下面是一个能同时适用这两种情况的题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">boolean</span> reverse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>reverse<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            reverse <span class="token operator">=</span> <span class="token operator">!</span>reverse<span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>
<hr>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><strong>思路：</strong> 利用 BFS 进行层次遍历，记录下每层的最后一个元素。</p>
<p><strong>时间复杂度：</strong> <em>O</em>(<em>N</em>)，每个节点都入队出队了 1 次。<br><strong>空间复杂度：</strong> <em>O</em>(<em>N</em>)，使用了额外的队列空间。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>  queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>思路：</strong> 我们按照 <code>「根结点 -&gt; 右子树 -&gt; 左子树」</code>的顺序访问，就可以保证每层都是最先访问最右边的节点的。</p>
<p>（与先序遍历 <code>「根结点 -&gt; 左子树 -&gt; 右子树」</code> 正好相反，先序遍历每层最先访问的是最左边的节点）</p>
<p><strong>时间复杂度：</strong> <em>O</em>(<em>N</em>)，每个节点都访问了 1 次。<br><strong>空间复杂度：</strong> <em>O</em>(<em>N</em>)，因为这不是一棵平衡二叉树，二叉树的深度最少是 <em>logN</em> , 最坏的情况下会退化成一条链表，深度就是 <em>N</em> ，因此递归时使用的栈空间是 <em>O</em>(<em>N</em>) 的。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从根节点开始访问，根节点深度是0</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 先访问 当前节点，再递归地访问 右子树 和 左子树。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">==</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。</span>
            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        depth<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<hr>
<p>本题解析请看<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/" target="_blank" rel="noopener">这里</a></p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
        TreeNode left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token keyword">return</span> left<span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p>
<hr>
<p>思路：</p>
<p>本题为验证二叉搜索树（BST），那么我们应该联想到二叉搜索树的特性，那就是：</p>
<blockquote>
<ol>
<li>若它的左子树不为空，那么左子树上所有节点的 key 都小于根节点的 key。</li>
<li>若它的右子树不为空，那么右子树上所有节点的 key 都大于根节点的 key。</li>
<li>它的左右子树也分别为二叉搜索树。</li>
</ol>
</blockquote>
<p>发现了吗，BST 的节点大小顺序为：<code>left</code> &lt; <code>root</code> &lt; <code>right</code>。</p>
<p>利用这一特性，很自然的我们就会想到 <strong>BST 的中序遍历其实就是一个递增的序列</strong>。</p>
<p>那么我们该如何验证某棵树是不是 BST，采用中序遍历，只需要看当前节点是否大于已经遍历的上一个节点就行了。</p>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> pre <span class="token operator">=</span> Long<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pre<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p><strong>总结</strong>：在我们看到<strong><em>二叉搜索树\</em></strong>这几个字的时候，脑子里应该自然想到它的几个特点：</p>
<ul>
<li>节点值大小顺序：<strong><code>left</code> &lt; <code>root</code> &lt; <code>right</code></strong>；</li>
<li><strong>二叉搜索树的中序遍历的结果是递增的</strong>。</li>
</ul>
<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<hr>
<p>这一题不算太难，但结合了二分查找的一些特性，所以单独拿出来讲讲。</p>
<p>题目描述：</p>
<blockquote>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
</blockquote>
<p>我们知道<strong>二叉搜索树的中序遍历结果正是一个按照升序排列的序列</strong>，那么这一题的意思显然就是让我们由一个按照升序排列的有序数组<strong>还原</strong>出一个二叉搜索树，因此我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树。又因为本题要求高度平衡，因此我们需要<strong>选择升序序列的中间元素作为根节点</strong>。这就又结合了上面提到的二分查找的特性了，即<strong>不断地找中间元素作为根节点</strong>。</p>
<hr>
<p>题解：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> TreeNode <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> TreeNode <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>lo <span class="token operator">></span> hi<span class="token punctuation">)</span>     <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>lo <span class="token operator">+</span> hi<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-02</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/LeetCode/" title="LeetCode">LeetCode </a><span class="leancloud_visitors"></span><span>About 9340 words, 31 min 8 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>