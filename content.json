{"pages":[{"title":"about","text":"🏆个人简介欢迎来到我的个人博客，我是skdjq。NEU软件工程硕士在读。 GitHub：https://github.com/skdjq LeetCode：https://leetcode-cn.com/u/skdjq 📑博客简介Hexo 框架 + Butterfly 主题博客中的部分图片源于网络，侵删本博客文章采用 CC BY-NC-SA 4.0 协议，转载请注明出处 🔑 技能学习基础课程： 数据结构和算法 计算机网络 操作系统 计算机组成原理 专业技能： Docker Linux基础 Redis JVM …… 每天的小目标坚持刷 LeetCode 。 项目☑️基于Spring Boot 框架的校园问答型交流平台 欢迎大家 Star 和 Fork，如对项目有疑问可随时联系我。","link":"/about/index.html"},{"title":"friends","text":"","link":"/friends/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"","link":"/link/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"导航","text":"","link":"/navigate/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Flood Fill算法","text":"Flood Fill算法Flood Fill算法又叫洪水填充算法，一般用于图像处理。用于题目上的话一般就是海上的陆地一类的题目。 这里以本题为例对Flood Fill算法进行讲解。 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。 你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。 请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 输入格式 输入包括多个数据集合。 每个数据集合的第一行是两个整数 WW 和 HH，分别表示 xx 方向和 yy 方向瓷砖的数量。 在接下来的 HH 行中，每行包括 WW 个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖；2）‘#’：红色的瓷砖；3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 输出格式 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 数据范围 1≤W,H≤201≤W,H≤20 输入样例： 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 输出样例： 45 本题我们采用DFS写法，具体流程如下： 伪代码： int dfs(int x, int y) { 标记此位置为已走过的点 枚举四个偏移量 if(邻格可走) { dfs(邻格坐标); } } 代码实现： #include using namespace std; const int N = 25; int m, n; int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; char arr[N][N]; int dfs(int x, int y) { arr[x][y] = '#'; int res = 1; for(int i = 0; i < 4; i++) { int a = x + dx[i]; int b = y + dy[i]; if(a >= 0 && a < n && b >= 0 && b < m && arr[a][b] == '.') { res += dfs(a, b); } } return res; } int main() { while(cin >> m >> n, n || m) { for(int i = 0; i < n; i++) { cin >> arr[i]; } int x, y; for(int i = 0; i < n; i++) { for(int j = 0; j < m; j++) { if(arr[i][j] == '@') { x = i; y = j; } } } cout < dfs(x, y) < endl; } return 0; }","link":"/2021/01/15/flood-fill-suan-fa/"},{"title":"快速排序和归并排序","text":"快速排序快速排序的核心思想是分治，其算法大体可分为三个部分： 确定一个分界点 pivot （这个分界点可以任取，一般来说取左端点或中间端点）； 调整区间，将小于 pivot 的数和大于 pivot 的数分开； 递归处小于 pivot 和大于 pivot 的部分。 这里我们用到了双指针，即在待排序数组的两端定义两个指针 i 和 j ，i 不断向右移动直到 q[i] &gt; pivot，j 不断向左移动直到 q[j] &lt; pivot，这时将 q[i] 和 q[j] 交换，之后递归进行处理。 这样处理的好处就是 i 左边的数永远是小于 pivot， j 右边的数永远是大于 pivot 。 下面给出快速排序的C++模板： void quick_sort(int q[], int l, int r){ if(l >= r) return; int x = q[l + (r - l) / 2], i = l - 1, j = r + 1; while(i &lt; j){ do i++; while(q[i] &lt; x); do j--; while(q[j] > x); if(i &lt; j){ swap(q[i], q[j]); } } quick_sort(q, l, j); quick_sort(q, j + 1, r); } （在使用此模板时轻易不要改动，否则容易出现边界问题。。。。） 归并排序归并排序的核心思想也是分治，其算法大体也可以分为三个部分： 确定分界点（这个分界点是数组的中点，不能改变）； 递归排序左半部分和右半部分； 归并–将两部分数组合二为一。 发现与快速排序不同的地方了吗？ 快速排序是先处理再递归，不需要使用额外的空间，而归并排序是先递归再处理，而且需要使用额外的空间。 此算法的核心就是如何将两排序数组合二为一，这里我们依然采用双指针法。我们开辟一个额外的数组空间 tmp ，定义两个指针分别指向已经分割好的两数组的第一个元素，然后对指针所指向的元素的值进行比较，取较小者加入新数组 tmp ，当其中一个数组全部加入后，将另一个数组按顺序加入 tmp 即可。 下面给出归并排序的Java模板： public static void mergeSort(int[] arr, int l, int r){ if(l >= r){ return; } int mid = l + (r - l) / 2; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r); } public static void merge(int[] arr, int l, int mid, int r){ int[] tmp = new int[r - l + 1]; int i = l, j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ if(arr[i] &lt;= arr[j]){ tmp[k++] = arr[i++]; }else{ tmp[k++] = arr[j++]; } } while(i &lt;= mid){ tmp[k++] = arr[i++]; } while(j &lt;= r){ tmp[k++] = arr[j++]; } for(int m = l, n = 0; m &lt;= r; ++m, ++n){ arr[m] = tmp[n]; } } 关于归并排序，有一个非常经典的小和问题： 在一个数组中， 每一个数左边比当前数小的数累加起来， 叫做这个数组的小和。 求一个数组 的小和。 例子： [1,3,4,2,5] 1左边比1小的数， 没有； 3左边比3小的数， 1； 4左边比4小的数， 1、 3； 2左边比2小的数， 1； 5左边比5小的数， 1、 3、 4、 2； 所以小和为1+1+3+1+1+3+4+2=16 思路： 通过归并排序进行求解，每次merge都能计算出一次小和，当要将两个排好序的两个子序列进行合并时，如果左边的当前值比右边的当前值要小，则说明这个值比右边的所有值都要小，所有就产生了arr[i] * (r - l + 1)个小和，通过这种进行计算，直到计算完成。 题解： public static int merge(int[] arr, int l, int mid, int r){ int[] tmp = new int[r - l + 1]; int i = l, j = mid + 1; int res = 0, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ if(arr[i] &lt; arr[j]){ res += (r - j + 1) * arr[i]; tmp[k++] = arr[i++]; }else{ tmp[k++] = arr[j++]; } } while(i &lt;= mid){ tmp[k++] = arr[i++]; } while(j &lt;= r){ tmp[k++] = arr[j++]; } for(int m = l, n = 0; m &lt;= r; ++m, ++n){ arr[m] = tmp[n]; } return res; } public static int mergeSort(int[] arr, int l, int r){ if(l >= r){ return 0; } int mid = l + (r - l) / 2; return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r); } public static void main(String[] args) { int[] arr = {1, 3, 4, 2, 5}; int res = mergeSort(arr, 0, arr.length - 1); System.out.println(res); } 快速排序和归并排序的核心思想都是分治，从另一种层面上理解，快速排序实质上就是一个二叉树的前序遍历，读到这里相信很多小伙伴是理解不了的，我们可以这样理解：快排的步骤是先构造一个分界点，然后再递归的处理左右子数组，这不就是二叉树的前序遍历（根左右）吗？同理，我们可以得出归并排序实质上就是一个二叉树的后序遍历。 这两个算法还是比较重要的，建议在理解的基础上背一手模板就很舒服。","link":"/2020/09/05/kuai-su-pai-xu-he-gui-bing-pai-xu/"},{"title":"并发修改异常出现的原因和解决方法","text":"关于并发修改异常问题的剖析迭代器遍历元素的过程中，通过集合是不能修改元素的，否则会出现并发修改异常。（java.util.ConcurrentModificationException） 案例： public class demo2 { public static void main(String[] args) { List list = new ArrayList(); list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); list.add(1, \"HELLO\"); Iterator it = list.iterator(); while(it.hasNext()) { String s = (String) it.next(); if(\"hello\".equals(s)) { list.add(\"test\"); } } } } 我们想在 list 中有 “hello” 的时候添加字符串 “test” ，但结果如下： Exception in thread \"main\" java.util.ConcurrentModificationException 这就是出现了并发修改异常。 产生原因：迭代器是依赖于集合存在的，当集合中修改了元素，迭代器并不知道，因此引发了并发修改异常。上面的案例就是在迭代器遍历元素的过程中，集合修改了元素，所以出现并发修改异常。 由此我们可以得出这样一个结论： 迭代器遍历元素的过程中，通过集合是不能修改元素的。 如何解决？ A：迭代器迭代元素，迭代器修改元素。 B：集合遍历元素，集合修改元素 A：迭代器迭代元素，迭代器修改元素。 由于 Iterator 迭代器没有添加功能，我们使用其子接口 ListIteator。 public class demo2 { public static void main(String[] args) { List list = new ArrayList(); list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); list.add(1, \"HELLO\"); ListIterator it = list.listIterator(); while(it.hasNext()) { String s = (String) it.next(); if(\"hello\".equals(s)) { it.add(\"test\"); // ListIterator 迭代器修改元素 } } System.out.println(list); } } 元素是跟在刚才迭代的元素的后面的。 打印结果： [hello, test, HELLO, world, java] B：集合遍历元素，集合修改元素 public class demo2 { public static void main(String[] args) { List list = new ArrayList(); list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); list.add(1, \"HELLO\"); for (int i = 0;i &lt; list.size();++i) { String s = (String)list.get(i); if(\"hello\".equals(s)) { list.add(\"test\"); //集合修改元素 } } System.out.println(list); } } 元素是在最后添加的。 打印结果： [hello, HELLO, world, java, test]","link":"/2020/05/14/bing-fa-xiu-gai-yi-chang-chu-xian-de-yuan-yin-he-jie-jue-fang-fa/"},{"title":"滑动窗口问题","text":"滑动窗口问题数组操作中有一个重要的方法：滑动窗口。 所谓滑动窗口，就是不断调节子序列的起始位置和终止位置，从而得到我们想要的结果。 在算法题中的应用场景： 关键词： 满足xxx条件（计算结果，出现次数，同时包含） 最长/最短 子串/子数组/子序列 例如：长度最小的子数组 通用思路寻找最长： 核心：双指针left和right都在起始点，right向右逐位开始滑动循环。在每次滑动过程中： 如果窗口内元素满足条件，right向右扩大窗口，并更新最优结果 如果窗口内元素不满足条件，left向右缩小窗口 right到达结尾。 寻找最短： 核心：双指针left和right都在起始点，right向右逐位开始滑动循环。在每次滑动过程中： 如果窗口内元素满足条件，left向右缩小窗口，并更新最优结果 如果窗口内元素不满足条件，right向右扩大窗口 right到达结尾。 代码模板寻找最长： 初始化left, result, bestResult for(int right = 0; right &lt; num.length; right++) { 窗口扩大，加入right对应元素，更新当前result while (result不满足要求) { 窗口缩小，移除left对应元素，left右移 } 更新最优结果bestResult } return bestResult;寻找最短： 初始化left, result, bestResult for (int right = 0; right &lt; nums.length; right++) { 窗口扩大，加入right对应元素，更新当前result while (result满足要求) { 更新最优结果bestResult 窗口缩小，移除left对应元素，left右移 } } return bestResult;leetcode209class Solution { public int minSubArrayLen(int target, int[] nums) { int left = 0; int result = Integer.MAX_VALUE; int sum = 0; for (int right = 0; right &lt; nums.length; right++) { sum += nums[right]; while (sum >= target) { result = Math.min(result, right - left + 1); sum -= nums[left++]; } } return result == Integer.MAX_VALUE ? 0 : result; } } 参考自： 代码随想录 红桃A士视频","link":"/2022/05/03/hua-dong-chuang-kou-wen-ti/"},{"title":"盘点搭建Hexo博客时踩过的坑","text":"搭建Hexo博客时踩过的一些坑使用Jsdelivr加速博客之前看了许多教程，一直都没能解决这个问题，困扰了我三四天之久。偶然间得到高手指点，才终于弄明白了这个问题。再次特别感谢云玩家大神对我的指导，这是他的网站https://zplayer.cloud/ 使用Jsdelivr加速博客时，我们并不需要像很多教程说的那样再去新建一个仓库，两个仓库绕来绕去很容易绕晕像我这样的新手玩家，我们只需要用我们原有的仓库即可。 你不需要注册, 甚至连登陆它的网站都不用, 就可以免费使用 Jsdelivr 加速, 简直业界良心啊有木有. Jsdelivr 可以加速 Github 上的静态文件, 很多主题都有配置, 我们这里介绍如何通过 Jsdelivr 引用 Github 资源. 你可以认为 Jsdelivr 里放了你传上 Github 的文件 (这个 ‘放’ 的过程是自动的, 只要 Github 上有资源, 就会被 ‘放’ 到 Jsdelivr 上), 由于 GFW 的关系, 国内访问 Github 上的资源是很慢的, 那么我们可以通过访问 Jsdelivr 来间接访问 Github 上的资源. Github 上的某个资源是有其位置的, 如何访问一个 Github 资源? 你只需要知道: 用户名 仓库名 资源在仓库中的位置 同样, Jsdelivr 中的某个资源也是有其位置, 如何访问一个经 Jsdelivr 加速的 Github 资源? 你同样只需要知道: 用户名 仓库名 资源在仓库中的位置 我们访问互联网上的资源均需要通过url（统一资源定位器） 当我们通过GitHub访问Github上的资源时，资源引用的url格式是： https://www.github.com/用户名/仓库名/master/资源在仓库中的位置 当我们通过Jsdelivr访问GitHub的资源时，资源引用的url格式是： https://cdn.jsdelivr.net/gh/**用户名/仓库名/资源在仓库中的位置** Jsdelivr加速的原理就是，把静态资源的 url 全部替换为 Jsdelivr 的 url （比如图片等资源）。 在一些主题中已经自带了 config 文件，那么我们根据上面的指示直接操作即可，以 matery 为例： 我们只需要按要求配置即可： jsDelivr: url: https://cdn.jsdelivr.net/gh/skdjq/skdjq.github.io 在我们配置完成后如果再按照hexo clean、hexo g、hexo d分步去执行可能会出现以下状况： 这是因为此时GitHub还没来得及更新造成的，原理我也不知道，但我们可以这样解决： hexo cl &amp;&amp; hexo g -d 这样就解决了。 Hexo引用图片不显示在很多时候，我们在插入图片的时候本地预览时明明可以显示，一旦hexo d布署到本地就显示不出来了，这属实令人头疼。那么我们到底有没有解决的方法呢，当然有，就是使用我们自己搭建的图床。 PicGo + Gitee搭建图床现在主流的图床搭建就是 PicGo + Gitee 或 PicGo + GitHub ，相比于 GitHub ，Gitee 访问图片的速度更快，但仓库容量却比 GitHub 小得多，但就我个人而言往往插入的图片不是很多，所以选用了加载速度更快的 PicGo + Gitee 搭建图床。 新建仓库这一步就不多说了，在 Gitee 新建一个仓库用来存放图片，名字任意，懂得都懂。 设置私人令牌 设置 -&gt; 私人令牌 -&gt; 生成新令牌 注意在生成新令牌之后，我们将令牌复制到剪切板中，待会要用，切记！ 配置Gitee图床首先我们需要下载 PicGo 软件，这个请读者自行百度下载。 接着打开软件，点击软件界面中的插件设置，然后进行搜索：输入内容：picgo-plugin-gitee，你会发现，有两个插件，选择第一种(gitee 1.2.2-beta)。 安装完成后，重启PicGo应用，图床设置选项就会出现一个Gitee图床，然后进行点击，设置如下内容： url：这里填写码云官方的网址 owner：填写你的用户名 repo：填写你的图床仓库名称 path：图片存储路径 token：填写上面教程中你设置的私人令牌 message：不需要填 之后我们将需要上传的图片拖入上传区即可，当我们再次引用图片时，直接引用 PicGo 图床里的图片即可。芜湖~准备起飞！","link":"/2020/04/14/pan-dian-da-jian-hexo-bo-ke-shi-cai-guo-de-keng/"},{"title":"报错org.apache.ibatis.binding.BindingException: Parameter 'xxxxx' not found.","text":"报错信息今天使用mybatis查询数据的时候，出现 org.apache.ibatis.binding.BindingException: Parameter ‘username’ not found. Available parameters are [0, 1, param1, param2] 问题。 org.apache.ibatis.binding.BindingException: Parameter 'username' not found. Available parameters are [0, 1, param1, param2] at org.apache.ibatis.binding.MapperMethod$ParamMap.get(MapperMethod.java:168) at org.apache.ibatis.reflection.wrapper.MapWrapper.get(MapWrapper.java:45) at org.apache.ibatis.reflection.MetaObject.getValue(MetaObject.java:122) at org.apache.ibatis.executor.BaseExecutor.createCacheKey(BaseExecutor.java:212) at org.apache.ibatis.executor.CachingExecutor.createCacheKey(CachingExecutor.java:139) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:81) 产生原因字面上,就是说Mybatis并没有匹配到这个参数。 解决方案使用注解@Param(“XXX”)来完成。 1.当只有一个参数时，Mapper/Dao层中的方法是可以不使用注解的。比如插入数据的时候： public void insertAdmin(String username); 2.多个参数时必须用@Param(“XXX”)来指明：比如登录验证的时候： public void insertAdmin(@Param(&quot;username&quot;)String username,@Param(&quot;password&quot;)String password); 此时再运行就不会再报错了。 总结在dao接口方法中的参数前面加@param注解情景： 当只有一个参数时，dao接口的方法中可不用添加注解。Mybatis可成功匹配参数。 当大于一个参数时，dao接口的方法中需要使用注解@Param(“XXX”)为Mybatis指定参数名称。","link":"/2020/07/16/bao-cuo-org-apache-ibatis-binding-bindingexception-parameter-xxxxx-not-found/"},{"title":"堆排序","text":"堆排序 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。 根据数组脑补出一颗完全二叉树： 对于数组中下标为i的节点： 左孩子下标：2i + 1 右孩子下标：2i + 2 父节点：(i - 1) / 2 务必牢记上述关系！ 什么是堆？ 堆就是一棵完全二叉树。 大根堆：任何一棵子树的最大值都是这棵子树的头部。 小根堆：任何一棵子树的最小值都是这棵子树的头部。 把一个数组转化成大根堆： heapInsert方法： 从0开始逐步扩大范围，根据父节点下标 = (i - 1) / 2将当前值与父节点比较，如果比父节点大就和父节点交换，直到不比父节点大为止。关键：上浮。 public static void heapInsert(int[] arr, int index){ while(arr[index] > arr[(index - 1) / 2]){ swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; } } 调整大根堆： heapify方法： 如果大根堆中某一个位置元素值减小，则该元素和其左右孩子中较大的那个交换，重新调整为大根堆。关键：下沉。 public static void heapify(int[] arr, int index, int heapSize){ int left = 2 * index + 1; while(left &lt; heapSize){ int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] > arr[left] ? left + 1 : left; largest = arr[largest] > arr[index] ? largest : index; if(largest == index){ break; } swap(arr, largest, index); index = largest; left = 2 * index + 1; } } 堆排序： 将数组建立成大根堆 每次把堆顶元素都和大根堆的最后一个元素交换 heapSize - 1，执行heapify方法 循环至heapSize为0 public class heapSort { public static void HeapSort(int[] arr){ if(arr == null || arr.length &lt; 2){ return; } // 建立大根堆 for(int i = 0; i &lt; arr.length; ++i){ heapInsert(arr, i); } int heapSize = arr.length; swap(arr, 0, --heapSize); while(heapSize > 0){ heapify(arr, 0, heapSize); swap(arr, 0, --heapSize); } } /** * 将数组转化为大根堆的关键-----------上浮 * */ public static void heapInsert(int[] arr, int index){ while(arr[index] > arr[(index - 1) / 2]){ swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; } } /** * 数组中若有数变小，调整大根堆-------下沉 * 可用于弹出堆的一个元素：将堆中最后一个元素与堆顶元素交换，然后heapsize - 1，从0位置上开始执行此方法 * */ public static void heapify(int[] arr, int index, int heapSize){ int left = 2 * index + 1; while(left &lt; heapSize){ int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] > arr[left] ? left + 1 : left; largest = arr[largest] > arr[index] ? largest : index; if(largest == index){ break; } swap(arr, largest, index); index = largest; left = 2 * index + 1; } } private static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void main(String[] args) { int[] arr = {1, 2, 1, 4, 5, 8, 5, 10, 2}; HeapSort(arr); for(int i = 0; i &lt; arr.length; ++i){ System.out.print(arr[i] + \" \"); } } } 关于堆排序，这里有个动图可以加深一下理解： 堆结构非常重要 堆结构的heapInsert和heapify 堆结构的增大和减少 如果只是建立堆的过程，时间复杂度为O(N) 优先级队列结构就是堆结构","link":"/2020/10/30/dui-pai-xu/"},{"title":"贡献墙","text":"贡献墙 感谢以下老板们对作者的支持 姓名 金额 平台 A Yuan 1.66元 微信 *扬 0.21元 支付宝 Arutoria 0.10元 微信 你们的赏识是我更新的动力，奥里给！！！","link":"/2020/04/13/gong-xian-qiang/"},{"title":"谈谈敏感词过滤的实现","text":"敏感词过滤最近在做一个项目的过程中正好遇到了敏感词过滤这一功能，由于这个功能应用广泛，就记录下来以便日后复习。 设计敏感词过滤可以通过Trie树来实现，即我们所说的前缀树/字典树。 Trie树Trie树也称为前缀树、字典树，最大的特点就是共享字符串的公共前缀来达到节省空间的目的了。 Trie树的根节点不存任何数据，每整个个分支代表一个完整的字符串。 Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。 举个简单的例子来说明一下。 我们有 6 个字符串，它们分别是：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 6 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？ 这个时候，我们就可以先对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。最后构造出来的就是下面这个图中的样子。 Trie树的应用 Trie树最大的特点就是利用了字符串的公共前缀，当我们在搜索框输入关键词时，搜索框会自动帮我们列举出相关结果： 在设计敏感词过滤的过程中，我们可以这样定义Trie树： 图中的红叉表示标记到这个字符，从root到此字符所经过的字符串是敏感词。 把所有敏感词存入Trie树中，设置三个指针：p1、p2、p3。 其中：p1指向Trie树的根节点，p2和p3指向待过滤的字符数组。 过滤过程过滤过程为： p1找root下一层有没有与p2指向相同的字符，若没有，p2和p3都向后移动；若有，p1指向那个字符对应的节点，p2不动，p3向后移动，然后重复上述过程。 如果p1指向了带标记的节点，那么将p2到p3中间的字符串统一用过滤词如***代替并存入结果数组中，p2和p3都移动到 p3 + 1的位置；如果没有指向带标记的节点，p2++，p3 == p2。当p3 == 数组长度时，将剩余字符加入结果数组中。 复杂度分析 如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。 如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。 代码实现这里构建Trie树我们使用HashMap实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。 @Component public class SensitiveFilter { private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class); private static final String REPLACEMENT = \"***\"; private TrieNode rootNode = new TrieNode(); private class TrieNode { // 关键词结束标识 private boolean isKeywordEnd = false; private Map&lt;Character, TrieNode> subNodes = new HashMap&lt;>(); public boolean isKeywordEnd() { return isKeywordEnd; } public void setKeywordEnd(boolean keywordEnd) { isKeywordEnd = keywordEnd; } // 添加子节点 public void addSubNode(Character c, TrieNode node) { subNodes.put(c, node); } // 获取子节点 public TrieNode getSubNode(Character c) { return subNodes.get(c); } } @PostConstruct public void init() { try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream(\"sensitive-words.txt\"); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) { String keyword; while ((keyword = reader.readLine()) != null) { // 添加到前缀树 this.addKeyword(keyword); } } catch (IOException e) { logger.error(\"加载敏感词文件失败: \" + e.getMessage()); } } private void addKeyword(String keyword) { TrieNode tmp = rootNode; for(int i = 0; i &lt; keyword.length(); i++) { char c = keyword.charAt(i); TrieNode subNode = tmp.getSubNode(c); if(subNode == null) { subNode = new TrieNode(); tmp.addSubNode(c, subNode); } tmp = subNode; if(i == keyword.length() - 1) { tmp.setKeywordEnd(true); } } } /** * 返回过滤后的文本 * */ public String filter(String text) { if(StringUtils.isBlank(text)) { return null; } TrieNode tmp = rootNode; int begin = 0; int position = 0; StringBuilder sb = new StringBuilder(); while(position &lt; text.length()) { char c = text.charAt(position); // 忽略特殊符号 if(isSymbol(c)) { if(tmp == rootNode) { sb.append(c); begin++; } position++; continue; } tmp = tmp.getSubNode(c); if(tmp == null) { // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); begin++; position = begin; tmp = rootNode; } else if (tmp.isKeywordEnd()) { sb.append(REPLACEMENT); position++; begin = position; } else { position++; } } // 将剩下的字符串加入结果中 sb.append(text.substring(begin)); return sb.toString(); } // 判断是否为符号 // 0x2E80 ~ 0x9FFF 是东亚文字范围 private boolean isSymbol(Character c) { return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c > 0x9FFF); } }","link":"/2020/12/01/tan-tan-min-gan-ci-guo-lu-de-shi-xian/"},{"title":"链表专题","text":"链表算法专题有关链表的题目，有一个常用的技巧：在头结点之前再建立一个虚拟结点，让虚拟结点指向头结点。 ListNode* dummyHead = new ListNode(-1); dummyHead->next = head; leetcode19/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyHead = new ListNode(); dummyHead->next = head; ListNode* p = dummyHead; ListNode* q = head; while (n--) { q = q->next; } while (q) { p = p->next; q = q->next; } p->next = p->next->next; return dummyHead->next; } }; leetcode237把当前结点伪装成下一个结点，再把下一个点删掉。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { ListNode* tmp = node->next; node->val = tmp->val; node->next = tmp->next; } }; leetcode83/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { ListNode* dummyHead = new ListNode(-1); dummyHead->next = head; ListNode* cur = head; while (cur) { while (cur->next && cur->val == cur->next->val) { cur->next = cur->next->next; } cur = cur->next; } return dummyHead->next; } }; leetcode61/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if (head == NULL) { return NULL; } int n = 0; for (auto cnt = head; cnt; cnt = cnt->next) { n++; } auto p = head, q = head; k %= n; while (k--) { q = q->next; } while (q->next) { p = p->next; q = q->next; } q->next = head; head = p->next; p->next = NULL; return head; } }; leetcode24本题为两两交换相邻的结点，可设虚拟头结点dummyHead，指针p指向dummyHead，指针a和b分别指向p-&gt;next和p-&gt;next-&gt;next，代码顺序为： /** * p->dummyHead; * a = p->next; * b = p->next->next */ p->next = b; a->next = b->next; b->next = a; /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(-1); dummyHead->next = head; for (auto p = dummyHead; p->next && p->next->next; ) { auto a = p->next, b = p->next->next; p->next = b; a->next = b->next; b->next = a; p = a; } return dummyHead->next; } }; leetcode206/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* p = NULL, *q = head; while (q) { ListNode* tmp = q->next; q->next = p; p = q; q = tmp; } return p; } };","link":"/2022/07/11/lian-biao-zhuan-ti/"},{"title":"贪心算法相关题目","text":"题目列表 题目名称 难度 11. 盛最多水的容器 Medium 435. 无重叠区间 Medium 455. 分发饼干 Easy 55. 跳跃游戏 Medium 盛最多水的容器题目链接：https://leetcode-cn.com/problems/container-with-most-water/ 思路：此题使用双指针碰撞和贪心思想，总是贪心先固定容器的宽度。根据木桶原理（盛水的高度由最短的那块木板决定），高的那块木板往里面走，只可能让盛水越来越少，但是短板往里面走，却有可能让盛水越来越多。 我认为写的比较好的题解是这篇。 代码： class Solution { public int maxArea(int[] height) { int length = height.length; int left = 0, right = length - 1; int res = 0; while(left &lt; right){ int area = Math.min(height[left], height[right]) * (right - left); res = Math.max(res, area); if(height[left] &lt; height[right]){ left++; }else{ right--; } } return res; } } 435. 无重叠区间题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/ 思路：题目要找到需要移除区间的最小数量，使剩余区间互不重叠，我们可以理解为找到最多的无重叠区间。 对于贪心算法中的区间问题，我们通常会考虑将区间按照右端点进行一个排序。此题也是如此，每个区间的结尾很重要，结尾越小，则后面越有可能容纳更多的区间。 代码： class Solution { public int eraseOverlapIntervals(int[][] intervals) { int length = intervals.length; if(length &lt; 2){ return 0; } Arrays.sort(intervals, Comparator.comparingInt(a -> a[1])); int res = 0; int end = intervals[0][1]; for(int i = 1; i &lt; length; ++i){ if(intervals[i][0] &lt; end){ res++; }else{ end = intervals[i][1]; } } return res; } } 455. 分发饼干题目链接：https://leetcode-cn.com/problems/assign-cookies/ 思路：对于一个孩子来说，如果小的饼干可以满足，我们就没必要用更大的饼干，这样更大的就可以留给其他对饼干大小需求更大的孩子。另一方面，对饼干大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配饼干。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。 我们每次从剩下的孩子中，找出对饼干大小需求最小的，然后发给他剩下的饼干中能满足他的最小的饼干，这就是典型的贪心算法，而这样得到的分配方案，也就是满足的孩子个数最多的方案。 代码： class Solution { public int findContentChildren(int[] g, int[] s) { if(g.length == 0 || s.length == 0){ return 0; } Arrays.sort(g); Arrays.sort(s); int i = 0, j = 0; int res = 0; while(i &lt; g.length &amp;&amp; j &lt; s.length){ if(g[i] &lt;= s[j]){ res++; i++; j++; }else{ j++; } } return res; } } 55. 跳跃游戏题目链接：https://leetcode-cn.com/problems/jump-game/ 从前向后 其实这题最好的解法不是 DP，而是贪婪算法 Greedy Algorithm。 因为我们并不关心每一个位置上的剩余步数，我们只希望知道能否到达末尾，也就是说我们只对最远能到达的位置感兴趣。 维护一个变量 reach，表示最远能到达的位置，初始化为 0。 遍历数组中每一个数字，如果当前坐标大于 reach 或者 reach 已经抵达最后一个位置则跳出循环，否则就更新 reach 的值为其和 i + nums[i] 中的较大值，其中 i + nums[i] 表示当前位置能到达的最大位置。 解题思路： 如果某一个作为起跳点的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为起跳点； 可以对每一个能作为起跳点的格子都尝试跳一次，把能跳到最远的距离不断更新； 如果可以一直跳到最后，就成功了。 代码： class Solution { public boolean canJump(int[] nums) { int maxReach = 0; for(int i = 0; i &lt; nums.length; i++){ if(i > maxReach){ return false; } maxReach = Math.max(maxReach, i + nums[i]); } return true; } } 参考： https://www.yuque.com/liweiwei1419/algo/newasc https://leetcode-cn.com/problems/jump-game/solution/55-by-ikaruga/","link":"/2020/10/03/tan-xin-suan-fa-xiang-guan-ti-mu/"},{"title":"IO流","text":"文件 三种常用创建文件的代码： // method1 new File(String pathname) public static void create1() { String filePath = \"E:\\\\test.txt\"; File file = new File(filePath); //这里的file在java程序中，只是一个对象 try { file.createNewFile(); //这里才创建文件到磁盘 System.out.println(\"文件创建成功\"); } catch (IOException e) { e.printStackTrace(); } } // method2 new File(File parent, String child) 根据父目录文件 + 子路径创建 public static void create2() { File parentFile = new File(\"E:\\\\\"); String fileName = \"test2.txt\"; File file = new File(parentFile, fileName); try { file.createNewFile(); System.out.println(\"文件创建成功\"); } catch (IOException e) { e.printStackTrace(); } } // method3 new File(String parentName, String childName) public static void create3() { String parentName = \"E:\\\\\"; String childName = \"test3.txt\"; File file = new File(parentName, childName); try { System.out.println(\"文件创建成功\"); file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } 常用操作： getName、getAbsolutePath、getParent、length（字节大小）、exists、isFile、isDirectory、delete等。 IO流流的分类： 按操作数据单位不同分为：字节流（8 bit）二进制文件，字符流（按字符） 文本文件 按数据流的流向不同分为：输入流，输出流 按流的角色的不同分为：节点流(FileReader、FileWriter等)，处理流/包装流(BufferedReader、BufferedWriter等) 抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputSream Writer InputStreamInputStream常用的子类： FileInputStream：文件输入流 BufferedIputStream：缓冲字节输入流 ObjectInputStream：对象字节输入流 FileInputStreampublic static void main(String[] args) { FileInputStream fileInputStream = null; byte[] buf = new byte[8]; int readLen = 0; try { fileInputStream = new FileInputStream(\"E:\\\\test.txt\"); // 可以read读字节，也可以read(byte[] byte)读一个字符数组 while ((readLen = fileInputStream.read(buf)) != -1) { System.out.print(new String(buf, 0, readLen)); } } catch (IOException e) { e.printStackTrace(); } finally { try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } OutputStreamFileOutputStreampublic static void main(String[] args) { /** * 注意：new FileOutputStream(filePath) 当写入内容时会覆盖原来的内容 * new FileOutputStream(filePath, true) 当写入内容时会追加到末尾 * */ String pathName = \"E:\\\\test2.txt\"; FileOutputStream fileOutputStream = null; try { fileOutputStream = new FileOutputStream(pathName, true); // 写入一个字节 fileOutputStream.write('a'); // 写入字符串 String str = \"hello, world!\"; fileOutputStream.write(str.getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { try { fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } FileReader操作和FileInputStream类似。 FileWriter操作和FileOutputStream类似。 new FilwWriter(File/String, true)追加到文件末尾 注意：FileWriter使用后，必须要关闭(close)或刷新(flush)！ BufferedInputStream和FileInputStream操作类似。 BufferedOutputStream和FileOutputStream操作类似。 BufferedReader是Reader的一个子类，是对节点流的包装。 例如：new BufferedReader(new FileReader(PathName)) bufferedReader.readLine() 按行读取文件，当返回null时，表示文件读取完毕。 BufferedWriter同BufferedReader，是Writer的一个子类，是对节点流的包装。 例如：new BufferedWriter(new FileWriter(PathName, true)) bufferWriter.write()等。 对象处理流 序列化：保存数据的值和数据类型（必须实现Serializable接口（常用）或Externalizable接口） 反序列化：恢复数据的值和数据类型 ObjectOutputStream提供序列化功能 ObjectInputStream提供反序列化功能 和BufferedReader和BufferedWriter类似，是包装类。 public class ObjectOutputStream_ { public static void main(String[] args) throws Exception { String pathName = \"E:\\\\test.txt\"; // 序列化 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(pathName)); objectOutputStream.writeInt(100); objectOutputStream.writeBoolean(true); objectOutputStream.writeObject(new Dog(\"小黄\", 1)); objectOutputStream.writeObject(new Dog(\"小黑\", 2)); objectOutputStream.close(); System.out.println(\"ok\"); // 反序列化，注意读取顺序 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(pathName)); System.out.println(objectInputStream.readInt()); System.out.println(objectInputStream.readBoolean()); Object obj = objectInputStream.readObject(); // 向下转型 注意：这里需要将Dog类的定义拷贝到可以引用的位置 Dog dog = (Dog)obj; System.out.println(\"姓名： \" + dog.getName() + \" 年龄： \" + dog.getAge()); objectInputStream.close(); System.out.println(\"ok\"); } } // 要被序列化的类一定要实现Serializable接口 class Dog implements Serializable { private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 对象处理流的使用细节： 读写顺序要一致 要求实现序列化或反序列化对象，需要实现Serializable 序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性 例如：private static final long SerialVersionUID = 1L 序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员 序列化对象时，要求里面属性的类型也需要实现序列化接口 序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化 面试题：close()和flush()的区别 close() 关闭流对象，但要先刷新一次缓冲区。关闭后流对象不可以继续被使用了。 flush() 仅仅刷新缓冲区，刷新之后流对象依然可以继续使用。 字节流和字符流使用情况：（重要）字符流和字节流的使用范围： 字节流一般用来处理图像，视频，以及PPT，Word类型的文件。 字符流一般用于处理纯文本类型的文件，如TXT文件等。 字节流可以用来处理纯文本文件，但是字符流不能用于处理图像视频等非文本类型的文件。 结论：只要处理纯文本类型的数据，优先考虑字符流，其余文件一律用字节流。 字节流和字符流的区别（重点）字节流和字符流的区别：(详细可以参见这篇文章) 字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。（close()方法在关闭字符流之前会强制刷新一遍缓冲区） 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。","link":"/2020/05/19/io-liu/"},{"title":"二分查找","text":"二分查找二分的两段性 注： 设计一个check函数， 如果函数的性质满足绿色部分，不满足红色部分，使用模板一。 如果函数的性质满足红色部分，不满足绿色部分，使用模板二。 模板一： int bsearch_1(int l, int r) { while (l < r) { int mid = l + r >> 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 模板二： int bsearch_2(int l, int r) { while (l < r) { int mid = l + r + 1 >> 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 二分的流程 确定二分边界 编写代码框架 设计一个check（性质） 设计完的check函数，答案一定要在性质的边界 判断区间如何更新 如果更新方式写的是l = mid, r = mid - 1，那么就在算mid的时候加上1（即模板2） 例题leetcode69显而易见这里要求向下取整，check函数为：t² &lt;= x， 在根号t左边，即红色部分满足这个性质 在根号t右边，即绿色部分不满足这个性质， 故使用模板二。 class Solution { public: int mySqrt(int x) { int l = 0, r = x; while (l < r) { int mid = l + (long long)r + 1 >> 1; if (mid = target 绿色部分满足，红色不满足 模板一 while (l < r) { int mid = l + r >> 1; if (nums[mid] >= target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return {-1, -1}; } else { start = l; } l = 0, r = nums.size() - 1; // 终止位置：小于等于target的最后一个数 // check():nums[mid] 1; if (nums[mid] 1; if (matrix[mid / n][mid % n] >= target) { r = mid; } else { l = mid + 1; } } if (matrix[l / n][l % n] == target) { return true; } else { return false; } } }; leetcode153该题旋转数组把数组分为两段。 设计的check函数满足绿色而不满足红色，且答案恰好在端点处。 class Solution { public: int findMin(vector& nums) { int l = 0, r = nums.size() - 1; while (l < r) { int mid = l + r >> 1; if (nums[mid] 1; if (nums[mid] = target) { r = mid; } else { l = mid + 1; } } if (nums[l] != target) { return -1; } else { return l; } } }; leetcode278满足是坏版本的第一个数，模板一。 // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int l = 1, r = n; while (l < r) { int mid = l + (long long)r >> 1; if (isBadVersion(mid)) { r = mid; } else { l = mid + 1; } } return l; } }; leetcode162（该题不适用模板）class Solution { public: int findPeakElement(vector& nums) { int l = 0, r = nums.size() - 1; while (l < r) { int mid = l + r >> 1; if (nums[mid] > nums[mid + 1]) { r = mid; } else { l = mid + 1; } } return l; } }; leetcode287（该题不适用模板）本题可根据抽屉原理做。有n + 1个苹果但只有n个抽屉，那么把抽屉分为两部分：(l, mid)和(mid + 1, r)，必定会有一边苹果的个数大于抽屉的个数。 同样的，把数组从中间一分为二，则必定有一边所包含元素的个数大于这一边区间的长度。 class Solution { public: int findDuplicate(vector& nums) { int n = nums.size() - 1; int l = 1, r = n; while (l < r) { int mid = l + r >> 1; // 统计左边元素个数 int cnt = 0; for (auto i : nums) { if (i >= l && i mid - l + 1) { r = mid; } else { l = mid + 1; } } return l; } }; leetcode275class Solution { public: int hIndex(vector& citations) { int l = 0, r = citations.size(); while (l < r) { int mid = l + r + 1 >> 1; if (citations[citations.size() - mid] >= mid) { l = mid; } else { r = mid - 1; } } return l; } };","link":"/2022/04/29/er-fen-cha-zhao/"},{"title":"关于SSM框架的整合","text":"SSM框架整合更为具体的整合教程请看这篇。 首先明白SSM是什么，SSM就是 Spring , SpringMVC , Mybatis。 配置 Maven我们首先要引入pom.xml文件，配置如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.skdjq&lt;/groupId> &lt;artifactId>coolmeeting&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>war&lt;/packaging> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>5.2.7.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;version>4.0.1&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-jdbc&lt;/artifactId> &lt;version>5.2.7.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.23&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.20&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.5&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis-spring&lt;/artifactId> &lt;version>2.0.5&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.9.5&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjrt&lt;/artifactId> &lt;version>1.9.5&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context-support&lt;/artifactId> &lt;version>5.2.7.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.freemarker&lt;/groupId> &lt;artifactId>freemarker&lt;/artifactId> &lt;version>2.3.28&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-databind&lt;/artifactId> &lt;version>2.11.1&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;/resource> &lt;resource> &lt;directory>src/main/resources&lt;/directory> &lt;/resource> &lt;/resources> &lt;/build> &lt;/project> 我这里是采用了 freemarker 模板，具体的可根据自己的情况更换。 整合SSM整合SSM是比较麻烦的，所以我们要有一个顺序，我的顺序是先整合 “SS”，即 Spring 和 SpringMVC，再整合 Mybatis。 首先对于 Spring 和 SpringMVC 有几个注意点： Spring 扫描除了 Controller 以外的所有包。 SpringMVC 扫描 Controller 包。 Mybatis 在 Spring 中配置。 视图解析器在 SpringMVC 中配置。 Spring 和 SpringMVC 的配置文件最终要在 web.xml中加载。 接下来就是我们的配置文件： applicationContext.xmlSpring —-&gt; applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;context:component-scan base-package=\"com.skdjq\" use-default-filters=\"true\"> &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;!-- 配置Mybatis --> &lt;context:property-placeholder location=\"classpath:db.properties\"/> &lt;bean class=\"com.alibaba.druid.pool.DruidDataSource\" id=\"dataSource\"> &lt;property name=\"username\" value=\"${db.username}\"/> &lt;property name=\"password\" value=\"${db.password}\"/> &lt;property name=\"url\" value=\"${db.url}\"/> &lt;/bean> &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\" id=\"sqlSessionFactoryBean\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;property name=\"typeAliasesPackage\" value=\"com.skdjq.model\"/> &lt;property name=\"mapperLocations\"> &lt;value> classpath*:com/skdjq/mapper/*.xml &lt;/value> &lt;/property> &lt;/bean> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\" id=\"mapperScannerConfigurer\"> &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/> &lt;!-- 接口文件位置 --> &lt;property name=\"basePackage\" value=\"com.skdjq.mapper\"/> &lt;/bean> &lt;!-- 事务配置 --> &lt;bean class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" id=\"transactionManager\"> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 注意：tx:advice必须是结尾为\"tx\"的 --> &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"> &lt;tx:attributes> &lt;tx:method name=\"add*\"/> &lt;tx:method name=\"update*\"/> &lt;tx:method name=\"delete*\"/> &lt;tx:method name=\"insert*\"/> &lt;/tx:attributes> &lt;/tx:advice> &lt;aop:config> &lt;aop:pointcut id=\"pcl\" expression=\"execution(* com.skdjq.service.*.*(..))\"/> &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pcl\"/> &lt;/aop:config> &lt;/beans> spring-servlet.xmlSpringMVC —-&gt; spring-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;context:component-scan base-package=\"com.skdjq\" use-default-filters=\"false\"> &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &lt;mvc:annotation-driven/> &lt;mvc:resources mapping=\"/**\" location=\"/\"/> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;mvc:mapping path=\"/**\"/> &lt;mvc:exclude-mapping path=\"/images/**\"/> &lt;mvc:exclude-mapping path=\"/styles/**\"/> &lt;bean class=\"com.skdjq.interceptor.PermissInterceptor\"/> &lt;/mvc:interceptor> &lt;/mvc:interceptors> &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"> &lt;property name=\"locations\"> &lt;list> &lt;value>classpath:freemarker-var.properties&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;bean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"> &lt;property name=\"templateLoaderPath\" value=\"/WEB-INF/ftl/\"/> &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/> &lt;property name=\"freemarkerVariables\"> &lt;map> &lt;entry key=\"root\" value=\"${root}\"/> &lt;/map> &lt;/property> &lt;property name=\"freemarkerSettings\"> &lt;props> &lt;prop key=\"template_update_delay\">10&lt;/prop> &lt;prop key=\"locale\">zh_CN&lt;/prop> &lt;prop key=\"datetime_format\">yyyy-MM-dd HH:mm:ss&lt;/prop> &lt;prop key=\"date_format\">yyyy-MM-dd&lt;/prop> &lt;prop key=\"time_format\">HH:mm:ss&lt;/prop> &lt;prop key=\"number_format\">#.####&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &lt;bean class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\"> &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.freemarker.FreeMarkerView\"/> &lt;property name=\"suffix\" value=\".ftl\"/> &lt;property name=\"allowRequestOverride\" value=\"true\"/> &lt;property name=\"allowSessionOverride\" value=\"true\"/> &lt;property name=\"exposeSessionAttributes\" value=\"true\"/> &lt;property name=\"exposeRequestAttributes\" value=\"true\"/> &lt;property name=\"contentType\" value=\"text/html;charset=utf-8\"/> &lt;/bean> &lt;/beans> 上面有很多是配置视图解析器的部分，大家可以根据情况做出调整。 web.xml我们需要把 Spring 和 SpringMVC 的配置文件加载到web.xml中： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!-- 加载Spring配置文件 --> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:applicationContext.xml&lt;/param-value> &lt;/context-param> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;!-- 加载SpringMVC配置文件 --> &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring-servlet.xml&lt;/param-value> &lt;/init-param> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!-- 编码过滤器 --> &lt;filter> &lt;filter-name>encodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>forceRequestEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>forceResponseEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>encodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;/web-app> 其中，编码过滤器每次都可以固定使用。 以上，就是整合 SSM 框架的具体内容，如有错误，敬请指正，感谢您的阅读。","link":"/2020/07/16/guan-yu-ssm-kuang-jia-de-zheng-he/"},{"title":"TCP的三次握手与四次挥手","text":"TCP TCP头部的报文结构 序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。 序号是本TCP报文数据部分的首字节序号，确认号是成功接收别人的TCP报文，并期待接收的下一个TCP报文中数据部分的首字节的序号。 TCP Flags URG：紧急指针标志 ACK：确认序号标志 PSH：push标志 RST：重置连接标志 SYN：同步序号，用于建立连接过程 FIN：finish标志，用于释放连接 需要注意的是： 不要将确认序号ack与标志位中的ACK搞混了。 确认方ack = 发起方seq + 1，两端配对。 三次握手TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。 TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。 “握手”是为了建立连接，流程图如下： 对于面试中的回答，可以这样说： 刚开始客户端处于 closed 状态，服务端处于 listen 状态。 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了连接。 对于seq和ack的值，个人有个不成熟的记忆方法： 即： 若上一段请求报文有seq0，本段请求报文的 ack1 = seq0 + 1。 若上一段请求报文有ack0，本段请求报文的 seq1 = ack0。 （1和0只是标记两段请求报文） 千万不要用大白话回答！ TCP 三次握手异常情况实战分析 TCP 第一次握手 SYN 丢包 当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 tcp_syn_retries 值后，客户端不再发送 SYN 包。 TCP 第二次握手 SYN、ACK 丢包 客户端发起 SYN 后，由于第二次握手 SYN、ACK 丢包，客户端是无法收到服务端的 SYN、ACK 包，当发生超时后，就会重传 SYN 包。 服务端收到客户的 SYN 包后，就会回 SYN、ACK 包，但是客户端一直没有回 ACK，服务端在超时后，重传了 SYN、ACK 包，接着一会，客户端超时重传的 SYN 包又抵达了服务端，服务端收到后，超时定时器就重新计时，然后回了 SYN、ACK 包，所以相当于服务端的超时定时器只触发了一次，又被重置了。 最后，客户端 SYN 超时重传次数达到了 5 次（tcp_syn_retries 默认值 5 次），就不再继续发送 SYN 包了。 所以，我们可以发现，当第二次握手的 SYN、ACK 丢包时，客户端会超时重发 SYN 包，服务端也会超时重传 SYN、ACK 包。 简单地说： 当 TCP 第二次握手 SYN、ACK 包丢了后，客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。 客户端 SYN 包超时重传的最大次数，是由 tcp_syn_retries 决定的，默认值是 5 次；服务端 SYN、ACK 包时重传的最大次数，是由 tcp_synack_retries 决定的，默认值是 5 次。 TCP 第三次握手 ACK 丢包 在建立 TCP 连接时，如果第三次握手的 ACK 服务端无法收到，则服务端就会短暂处于 SYN_RECV 状态，而客户端会处于 ESTABLISHED 状态。 由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 tcp_synack_retries 值（默认值 5 次）后，服务端就会断开 TCP 连接。 而客户端则会有两种情况： 如果客户端没发送数据包，一直处于 ESTABLISHED 状态，然后经过较长一段时间才可以发现一个「死亡」连接，于是客户端连接就会断开连接。 如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 tcp_retries2 值（默认值 15 次）后，客户端就会断开 TCP 连接。 三次握手常见面试题 三次握手有什么作用？ 确认双方的接收能力、发送能力是否正常。 指定自己的初始化序列号，为后面的可靠传送做准备。 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。 （ISN）是固定的吗？ 三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。 如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 这里再补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s… 三次握手过程中可以携带数据吗？ 第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。 首次握手有什么隐患？ 会出现SYN超时。 服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认。 于是服务端不断重试直到超时，Linux默认等待63秒才断开连接。 防护措施： SYN队列满后，通过 tcp_syncookies参数会发SYN cookie【源端口+目标端口+时间戳组成】。 若为正常连接则Client会回发SYN Cookie，直接建立连接。 建立连接，Client出现故障怎么办？ 利用保活机制： 向对方发送保活探测报文，如果未收到响应则继续发送。 当尝试次数达到保活探测数仍然未收到响应则中断连接。 为什么一定要进行三次握手？两次不行吗？ 首先我们要弄明白三次握手的目的： 第一次握手：客户端发包，服务端收到了。 这样服务端会得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。 这样客户端会得出结论：客户端的发送、接收能力是正常的，服务端的发送、接收能力也是正常的。 但是要注意，此时服务端并不能确认客户端的接受能力是否是正常的。 于是就有了第三次握手：客户端发包，服务端收到了。 这样服务端就能得出最终结论：客户端的发送、接收能力是正常的，服务端的发送、接收能力也是正常的。 如果用了两次握手，则有可能会发生下面这种情况： 客户端向服务端发出一个连接请求，但由于某种原因该连接请求报文丢失了，于是客户端又向服务端发送了一个连接请求，这次一切正常，建立连接后进行数据传输，然后释放连接，注意：客户端一共发送了两个连接请求报文段，一个丢失，一个到达服务端。但如果丢失的那个请求在某个网络节点滞留了，延迟了一会才到达服务端，这时服务端就会误以为客户端又发送了一次新的连接请求，而由于只有两次握手，此时服务端只要发出确认就能够建立新的连接了。但此时客户端会忽略服务端发来的确认，不进行数据传输，那么服务端就会一直等待客户端发送数据，造成资源的浪费。 四次挥手 第一次挥手：客户端发送一个FIN，用来关闭客户端和服务端的数据传送，客户端进入FIN_WAIT_1状态。 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号 ack = seq + 1，服务端进入CLOSE_WAIT状态。 第三次挥手：服务端发送一个FIN，用来关闭服务端和客户端的数据传送，服务端进入LAST_ACK状态。 第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号 ack = seq + 1，服务端进入CLOSED状态，完成四次挥手。 注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。 四次挥手常见面试题 为什么挥手需要四次？ 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次 为什么会有TIME_WAIT状态，且超过2MSL？ 主动发起关闭连接的一方，才会有 TIME-WAIT 状态。 TIME-WAIT 作用：等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭 原因： 1.防止关闭后又建立的新连接接收到旧连接的数据包 假设TIME_WAIT等待过短，那么被复用的端口可能会建立新的TCP连接 此时旧的连接在四次握手前可能有一个旧的数据包刚刚到达（图中SEQ=301） 这样新的连接就会处理旧的服务端数据包，产生数据错乱等严重问题。 经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。 2.等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭 如果服务端发送了FIN后，没有接收到客户端的ACK报文，则会超时重传再次发送FIN。 所以需要客户端等待2MSL，确保服务端接收到了ACK报文。 服务器出现大量CLOSE_WAIT状态的原因？ 对方关闭socket连接，而我方忙于读或写，没有及时关闭连接。 解决措施： 检查代码，特别是释放资源的代码。 检查配置，特别是处理请求的线程配置。 看到这里，希望读者对于以下几个问题都有了答案。 请画出三次握手和四次挥手的示意图 为什么连接的时候是三次握手？ 什么是半连接队列？ ISN(Initial Sequence Number)是固定的吗？ 三次握手过程中可以携带数据吗？ 如果第三次握手丢失了，客户端服务端会如何处理？ SYN攻击是什么？ 挥手为什么需要四次？ 四次挥手释放连接时，等待2MSL的意义? 参考资料： 剑指Java面试-Offer直通车 https://mp.weixin.qq.com/s/jTDU-zxP1INTYLpGLypjXQ https://zhuanlan.zhihu.com/p/63690137 https://zhuanlan.zhihu.com/p/86426969","link":"/2020/10/29/tcp-de-san-ci-wo-shou-yu-si-ci-hui-shou/"},{"title":"双指针算法","text":"双指针算法双指针算法模板： for(int i = 0, j = 0; i &lt; n; i++) { while(j &lt; i &amp;&amp; check(i, j)) { j++; } // 题目具体逻辑 } 基本上双指针算法的模板就是这样，check()函数指j满足某种条件。 核心思想双指针的算法的核心思想在于把复杂度为O(n ^ 2)的朴素算法优化到O(n)： for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { } } 将上面的朴素算法优化到O(n) 题目列表 题目名称 难度 16. 最接近的三数之和 Medium 167. 两数之和 II - 输入有序数组 Easy 658. 找到 K 个最接近的元素 Medium 42. 接雨水 Hard Acwing 800. 数组元素的目标和 Easy AcWing 799.最长连续不重复子序列 Easy AcWing 2816. 判断子序列 Easy 这几个题目都是非常经典的双指针算法题目，需要好好掌握~~ 800. 数组元素的目标和题目链接：https://www.acwing.com/problem/content/802/ 思路：采用双指针算法，定义两个指针i和j，其中i在A数组开始位置，j在B数组结束位置。 A[i] + B[j] &gt; x：j-- 可套上述模板解决： #include #include using namespace std; const int N = 100010; int n; int m; int x; int A[N], B[N]; int main() { // 处理输入输出 cin >> n >> m >> x; for(int i = 0; i < n; i++) { cin >> A[i]; } for(int i = 0; i < m; i++) { cin >> B[i]; } // 双指针算法 for(int i = 0, j = m - 1; i < n; i++) { while(j >= 0 && A[i] + B[j] > x) { j--; } if(A[i] + B[j] == x) { cout < i < \" \" < j < endl; break; } } return 0; } a[i]; } for(int i = 0; i < m; i++) { cin >> b[i]; } int i = 0, j = 0; while(i < n && j < m) { if(a[i] == b[j]) { i++; } j++; } if(i == n) { cout < \"Yes\" < endl; } else { cout < \"No\" < endl; } return 0; } 0){ if((x - arr[left]) &lt;= (arr[right] - x)){ right--; }else{ left++; } removeSize--; } List&lt;Integer> res = new ArrayList&lt;Integer>(); for(int i = left; i &lt;= right; ++i){ res.add(arr[i]); } return res; } } 42. 接雨水题目链接：https://leetcode-cn.com/problems/trapping-rain-water/ 此题使用双指针对撞，有三个定理： 定理一：在某个位置i处，它能存的水，取决于它左右两边的最大值中较小的一个。 定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值） 定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。 right_max left_max __ __ | | | |__ __?????????????????????? | | __| |__| __| |__ left right 代码： class Solution { public int trap(int[] height) { int length = height.length; if(length &lt; 3){ return 0; } // 注意初值的选取，前面做了特判，下标 0 和 len - 1 位置都不存雨水，因此这里有效 // 在区间 [1, len - 2] 里计算存水量 int left = 1, right = length - 2; int CurLeftHighest = height[0], CurRightHighest = height[length - 1]; int res = 0; // 这里是等于，因为当 left == right 的时候，left(right) 这个位置的存水量还需要计算一下 while(left &lt;= right){ int MinHeight = Math.min(CurLeftHighest, CurRightHighest); // 存水单位体积取决于较短的那个柱形的高度 if(MinHeight == CurLeftHighest){ // 大于当前，才可以存水 if(MinHeight > height[left]){ res += MinHeight - height[left]; } // 更新左边的柱形的最高高度 CurLeftHighest = Math.max(CurLeftHighest, height[left]); // 指针右移 left++; }else{ if(MinHeight > height[right]){ res += MinHeight - height[right]; } CurRightHighest = Math.max(CurRightHighest, height[right]); right--; } } return res; } }","link":"/2020/09/06/shuang-zhi-zhen-suan-fa-xiang-guan-ti-mu/"},{"title":"C++学习记录","text":"C++学习记录类和对象 类是现实世界或思维世界在实体计算机中的反映，它将数据以及这些数据上的操作封装在一起。对象是具有类型的变量。 对象是类的实例，类是对象的模板。 举一个简单的例子，人类与张三，人类就代表一个类，而张三就是人类里面的一个实例。 创建一个类在创建一个类时，我们常采用class+类名创建，如： class Student{ //访问权限 public: //属性 string m_name; int m_age; //行为 void showName() { cout < m_name < endl; } void showAge() { cout < m_age < endl; } };","link":"/2020/04/25/c-xue-xi-ji-lu/"},{"title":"LeetCode刷题汇总（不再更新）","text":"本篇是记录本人在刷leetcode过程中的题解及经验总结，望读者善用Ctrl + F。 数组篇删除排序数组中的重复项题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 解题核心思想：双指针。 注意本题目的数组是有序的，这就说明重复的元素必然相邻。 题目要求不使用额外空间删除重复项，那么就说明这一题我们可以把不重复的元素都挪到数组的左边，最后返回不重复元素的个数即可。 解法： 定义一个指针 p 指向数组第一个元素，定义一个指针 q 指向数组的第二个元素； 比较 nums[p] 和 nums[q]： 如果 nums[p] == nums[q] ：q 向后移动一位； 如果 nums[p] != nums[q]：把 nums[q] 的值赋给 nums[p + 1]，p 和 q 都向后移动一位； 返回 p + 1。 优化： 考虑如下数组： 此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。 因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。 题解： int length = nums.length; int p = 0, q = 1; while(q &lt; length){ if(nums[p] != nums[q]){ if(q - p > 1){ nums[p + 1] = nums[q]; } p++; } q++; } return p + 1; 二分查找篇搜索旋转排序数组题目链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array 本题的难点在于我们并不知道这个数组旋转了几次，由传统的二分查找模板我们知道需要比较 nums[mid] 和 target 的值的大小来判断区间，但在此旋转数组中我们无法直接这样比较，因为二分查找的前提是数组有序。因此，我们需要讨论 nums[mid] 和 target 所处的区间位置。即： 先根据 nums[mid] 与 nums[low] 的关系判断 mid 是在左段还是右段，接下来再判断 target 是在 mid 的左边还是右边，从而来调整左右边界 low 和 high。 题解： class Solution { public int search(int[] nums, int target) { int low = 0, high = nums.length - 1; while(low &lt;= high){ int mid = low + (high - low) / 2; if(nums[mid] == target){ return mid; } //说明 mid 在左段 if(nums[mid] >= nums[low]){ //说明 target 在左段 if(target &lt; nums[mid] &amp;&amp; target >= nums[low]){ high = mid - 1; }else{ low = mid + 1; } }else{ if(target &lt;= nums[high] &amp;&amp; target > nums[mid]){ low = mid + 1; }else{ high = mid - 1; } } } return -1; } } 搜索旋转排序数组 II题目链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii 这一题在上一题的基础上添加了一个条件：有重复元素，我们只需要加上这段代码就行了： if(nums[low] == nums[mid] &amp;&amp; nums[high] == nums[mid]) { low++; high--; continue; } 题解： class Solution { public boolean search(int[] nums, int target) { int low = 0; int high = nums.length - 1; while(low &lt;= high){ int mid = low + (high - low) / 2; if(nums[mid] == target){ return true; } if(nums[low] == nums[mid] &amp;&amp; nums[high] == nums[mid]) { low++; high--; continue; } if(nums[mid] >= nums[low]){ if(target >= nums[low] &amp;&amp; target &lt; nums[mid]){ high = mid - 1; }else{ low = mid + 1; } }else{ if(target &lt;= nums[high] &amp;&amp; target > nums[mid]){ low = mid + 1; }else{ high = mid - 1; } } } return false; } } 总结： 这一题难就难在我们无法直接判断区间，所以需要分段讨论 nums[mid] 和 target 所在的区间是左还是右。 还有一个非常相似的题目：https://leetcode-cn.com/problems/search-rotate-array-lcci 这一题是在本题的基础上考虑了重复元素，要求返回重复元素的最小下标。由于本人精力有限，这题暂且先搁置一段时间。 链表篇K个一组翻转链表题目地址：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/ 本体的关键在于知道什么时候可以反转什么时候停止反转，并且链表的断开与重连要把握好。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { if(head == null || head.next == null) { return head; } ListNode dummy = new ListNode(); dummy.next = head; ListNode pre = dummy, end = dummy; while(end != null) { for(int i = 0; i &lt; k &amp;&amp; end != null; i++) { end = end.next; } if(end == null) { break; } ListNode tmp = end.next; end.next = null; ListNode start = pre.next; pre.next = reverse(start); start.next = tmp; pre = start; end = start; } return dummy.next; } public static ListNode reverse(ListNode head) { if(head == null || head.next == null) { return head; } ListNode p = null, q = head; while(q != null) { ListNode tmp = q.next; q.next = p; p = q; q = tmp; } return p; } } 两数相加题目地址：https://leetcode-cn.com/problems/add-two-numbers/ 对于这类两数相加问题，我们需要考虑进位和补零，在两个节点的value相加大于等于10时，我们就需要进位，当一个节点为空而另一个节点不为空时，我们就要对空节点的value值进行补零操作。 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode cur = dummy; int carry = 0; while(l1 != null || l2 != null){ int x = l1 == null ? 0 : l1.val; int y = l2 == null ? 0 : l2.val; int sum = x + y + carry; carry = sum / 10; sum = sum % 10; cur.next = new ListNode(sum); cur = cur.next; if(l1 != null){ l1 = l1.next; } if(l2 != null){ l2 = l2.next; } } if(carry != 0){ cur.next = new ListNode(carry); } return dummy.next; } } 其中，carry表示进位。 如果这道题能够理解，那么两数相加Ⅱ也就迎刃而解了。这道题主要是需要把链表翻转过来再进行上面那道题的操作，我们先来熟悉一下链表的反转： private ListNode reverse1(ListNode head){ ListNode pre = null; ListNode cur = head; while(cur != null){ ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } 如果是还不太熟悉链表的反转，建议先去做一下这道题目：206. 反转链表。 下面是完整题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2){ ListNode dummy = new ListNode(0); ListNode cur = dummy; ListNode r1 = reverse(l1); ListNode r2 = reverse(l2); int carry = 0; while(r1 != null || r2 != null){ int x = r1 == null ? 0 : r1.val; int y = r2 == null ? 0 : r2.val; int sum = x + y + carry; carry = sum / 10; sum = sum % 10; cur.next = new ListNode(sum); cur = cur.next; if(r1 != null){ r1 = r1.next; } if(r2 != null){ r2 = r2.next; } } if(carry != 0){ cur.next = new ListNode(carry); } ListNode rr = reverse(dummy.next); return rr; } private ListNode reverse(ListNode l){ ListNode pre = null; ListNode cur = l; while(cur != null){ ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } } 对于两数相加Ⅱ，我们还可以用栈来实现，这里推荐去看一下力扣的评论区，在此不再赘述。 删除链表的倒数第N个节点题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 本题实在是经典，不得不拿出来说说了。 鉴于两次遍历大家都会，我就不在此细说了，想看详细解说可以去本题的讨论区逛一逛，本篇博客主要讲使用双指针一次遍历的解法。 思路： 提到删除，我们自然而然的就会想到找到要删除的节点的前一个节点，将它的指针域指向要删除节点的后一个节点，也就是 p.next = p.next.next，而这题也不例外，我们需要找到该节点的前一个节点。 我们可以设想假设设定了双指针 p 和 q的话，当 q指向末尾的 null，p与 q 之间相隔的元素个数为 n时，那么删除掉 p 的下一个指针就完成了要求。 流程： 设置一个虚拟节点 dummy 指向 head； 定义两个指针 p 和 q 同时指向 dummy； 让指针 q 移动 n + 1 个位置，使 p 和 q 的间距（不包含两头）为 n； 再使 q 和 p 同时移动，直至 q为 null ，此时，p 正好指向要被删除的元素的前一个元素； 接下来该干什么就不用我说了吧？懂得都懂，芜湖，起飞！ 为了方便理解，在此，引用一下程序员吴师兄精心制作的动图： 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode p = dummy; ListNode q = dummy; int length = 0; while(length &lt; n + 1){ q = q.next; length++; } while(q != null){ q = q.next; p = p.next; } p.next = p.next.next; return dummy.next; } } 合并两个有序链表题目地址：https://leetcode-cn.com/problems/merge-two-sorted-lists/ 本题有两种解法，一种迭代，一种递归。 迭代我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。 流程： 先创建一个哑节点 dummy，定义一个指针 pre 指向 dummy； 比较两链表各节点的值 val，使 pre 和 l1 or l2 同时向后移动一位； 到其中一个链表为空时，将另一个链表拼接至结果链表就行了。 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode pre = dummy; while(l1 != null &amp;&amp; l2 != null){ if(l1.val &lt;= l2.val){ pre.next = l1; l1 = l1.next; }else{ pre.next = l2; l2 = l2.next; } pre = pre.next; } pre.next = (l1 == null ? l2 : l1); return dummy.next; } } 递归递归解法我也不是很明白，就暂且把代码放上来，以后慢慢理解吧。 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1 == null) { return l2; } if(l2 == null) { return l1; } if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } } 反转部分链表题目地址：https://leetcode-cn.com/problems/reverse-linked-list-ii/ 本题是反转链表的进阶版，不熟悉反转链表的可以看我的这篇博客。 正如反转链表一样，这一题我们依然可以使用双指针来解决。 流程： 定义一个哑节点 dummy； 定义两个指针 p 和 q，一前一后； 使指针 q 指向反转的起始位置，p 指向 q 的前一个节点； 将 q 后面的节点依次删除，并利用头插法插入到 p 指向节点的后面。 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode p = dummy; ListNode q = dummy.next; int length = 0; while(length &lt; m - 1){ p = p.next; q = q.next; length++; } for(int i = 0; i &lt; n - m; ++i){ ListNode tmp = q.next; q.next = q.next.next; tmp.next = p.next; p.next = tmp; } return dummy.next; } } 环形链表题目地址：https://leetcode-cn.com/problems/linked-list-cycle/ 本题有两种解法，一种是使用哈希表的暴力解法，还有一种是使用快慢指针的巧妙解法。 下面将着重介绍快慢指针解法。 快慢指针当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。 根据上面的原理得出，如果一个链表存在环，那么快慢指针必然会相遇。 题解： /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; if(slow == fast){ fast = head; while(slow != fast){ slow = slow.next; fast = fast.next; } return true; } } return false; } } 哈希表如果一个链表是环形链表，那么必然有若干个节点会被遍历多次。 我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。 如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。 如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。 题解： /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public boolean hasCycle(ListNode head) { Set&lt;ListNode> nodesSeen = new HashSet&lt;>(); while (head != null) { if (nodesSeen.contains(head)) { return true; } else { nodesSeen.add(head); } head = head.next; } return false; } 总结：在环形链表问题上，使用快慢指针解法非常方便。 回文链表题目地址：https://leetcode-cn.com/problems/palindrome-linked-list/ 这一题我采用的是 暴力解法1： 将链表转换为数组，然后利用双指针从数组的两端比较值是否相等。 2020/11/2更新： 暴力解法2：使用一个栈结构，将链表的每个节点放入栈中，然后将每个链表节点值与栈弹出的元素比较。 额外空间复杂度为O(1)的解法： 先用快慢指针定位到链表的中点，然后反转后半部分链表，两指针分别从头和尾移动，比较节点值。 最后不要忘记还原链表！ 暴力解法1题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ArrayList&lt;Integer> list = new ArrayList&lt;>(); ListNode tmp = head; while(tmp != null){ list.add(tmp.val); tmp = tmp.next; } int slow = 0; int fast = list.size() - 1; while(slow &lt; fast){ if(!list.get(slow).equals(list.get(fast))){ return false; } slow++; fast--; } return true; } } 精妙解法： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { if (head == null || head.next == null) { return true; } ListNode n1 = head; ListNode n2 = head; while (n2.next != null &amp;&amp; n2.next.next != null) { // find mid node n1 = n1.next; // n1 -> mid n2 = n2.next.next; // n2 -> end } n2 = n1.next; // n2 -> right part first node n1.next = null; // mid.next -> null ListNode n3 = null; while (n2 != null) { // right part convert n3 = n2.next; // n3 -> save next node n2.next = n1; // next of right node convert n1 = n2; // n1 move n2 = n3; // n2 move } n3 = n1; // n3 -> save last node n2 = head;// n2 -> left first node boolean res = true; while (n1 != null &amp;&amp; n2 != null) { // check palindrome if (n1.val != n2.val) { res = false; break; } n1 = n1.next; // left to mid n2 = n2.next; // right to mid } n1 = n3.next; n3.next = null; while (n1 != null) { // recover list n2 = n1.next; n1.next = n3; n3 = n1; n1 = n2; } return res; } } 相交链表题目地址： https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/ 这两题都是相交链表问题。 本题仅用文字可能说不太明白，建议大家看这里的视频讲解。 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode pA = headA; ListNode pB = headB; while(pA != pB){ pA = (pA == null ? headB : pA.next); pB = (pB == null ? headA : pB.next); } return pA; } } 旋转链表题目地址：https://leetcode-cn.com/problems/rotate-list 本题在面试中比较常考，应好好掌握。 思路：既然是每次将链表向右移动 k 个长度，那么我们可以联想到环，可以先把链表成环，然后再根据题目的要求从环的某一处断开不就可以了吗？ 为了方便理解，在此我引用大佬liweiwei1419的图： 题解： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null || head.next == null || k == 0) return head; ListNode fast = head; int length = 1; while(fast.next != null){ fast = fast.next; length++; } k = k % length; if(k == 0) return head; ListNode slow = head; for(int i = 0; i &lt; length - k - 1; ++i){ slow = slow.next; } ListNode newHead = slow.next; slow.next = null; fast.next = head; return newHead; } } 小结： 如果当前指针 p 在 head 节点上，且 head 节点的值是有效的，那么指针 p 只需要移动 length - k - 1 次就可以移动到链表的倒数第 k 个节点的前一个结点了。 判断链表长度可以用 while 循环：定义一个指针 q 在头节点，循环条件为 q.next != null。 向右旋转链表是从链表的倒数第 k 个节点前断环，向左旋转链表则是从链表的正数第 k 个节点后断环。 复杂链表的复制题目地址： 剑指 Offer 35. 复杂链表的复制 138. 复制带随机指针的链表 本题是复制一个带随机指针的链表，我们使用HashMap。 因为是复制链表，所以我们需要先复制每一个节点，由于HashMap可以存储任意类型的值，这里我们就可以想到使用HashMap来复制节点： HashMap&lt;Node, Node> map = new HashMap&lt;>(); 复制完节点后，就需要复制指针，这里我们就需要用到 map 的 put 方法和 get 方法，具体如下图： 具体代码如下： /* // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } */ class Solution { public Node copyRandomList(Node head) { HashMap&lt;Node, Node> map = new HashMap&lt;>(); Node cur = head; while(cur != null){ map.put(cur, new Node(cur.val)); cur = cur.next; } cur = head; while(cur != null){ map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; } return map.get(head); } } 对于复制指针，我们一定要注意不能写成这样： map.get(cur).next = cur.next; map.get(cur).random = cur.random; 这样是错误的！因为我们是要返回一个新的链表，如果是上面这种情况，新的链表就会指向旧的链表，从而出错！ 栈篇有效的括号题目地址：https://leetcode-cn.com/problems/valid-parentheses 思路： 此题是栈的一个常见应用，即判断括号的有效性。根据栈后进先出的特性，我们可以将括号push进栈中，待需要对比时pop出来即可。 题解： class Solution { public boolean isValid(String s) { Stack&lt;Character> stack = new Stack&lt;Character>(); for(char c : s.toCharArray()){ if(c == '('){ stack.push(')'); }else if(c == '['){ stack.push(']'); }else if(c == '{'){ stack.push('}'); }else if(stack.isEmpty() || c != stack.pop()){ return false; } } return stack.isEmpty(); } } 二叉树篇590. N叉树的后序遍历题目链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/ 思路： 后序遍历即根节点在最后，我们可以使用LinkedList的addFirst()方法每次都将元素插入链表的第一个节点中，这样最先插入的根节点就会移动到链表的最后去了。 使用 LinkedList 创建两个链表，初次判断根节点是否为空，如果为空，则返回空链表。如果不为空，将根节点插入链表2的第一个节点中，然后判断链表2是否为空，若不为空，将链表2中的唯一一个节点插入链表1的头一个节点中，遍历根节点的子节点，若不为空，插入链表2中，反复循环直至链表2为空。 题解： /* // Definition for a Node. class Node { public int val; public List&lt;Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node> _children) { val = _val; children = _children; } }; */ class Solution { public List&lt;Integer> postorder(Node root) { LinkedList&lt;Integer> res = new LinkedList&lt;Integer>(); LinkedList&lt;Node> stack = new LinkedList&lt;Node>(); if(root == null) return res; stack.push(root); while(!stack.isEmpty()){ Node node = stack.pop(); res.addFirst(node.val); for(Node child:node.children){ if(child != null){ stack.push(child); } } } return res; } } 补充： Java 集合 LinkedList push()和pop()方法 public void push(E e)：将元素插入列表的前面。 public E pop()：删除并返回列表的第一个元素。 101. 对称二叉树题目链接：https://leetcode-cn.com/problems/symmetric-tree/ 思路： 1.判断根节点是否为空——–空返回true2.判断左右子树是否对称———对称就返回true2.1.当左子树的左节点等于右子树的右节点，且左子树的右节点等于右子树的左节点时对称3.递归终止条件：3.1.左子树右子树均为null——–true3.2.左子树右子树只有一个为null——–false3.3.左子树的值不等于右子树的值——–false 递归流程图 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution{ public boolean isSymmetric(TreeNode root){ if(root == null) return true; return LR(root.left,root.right); } public boolean LR(TreeNode leftChild,TreeNode rightChild){ if(leftChild == null &amp;&amp; rightChild == null) return true; if(leftChild == null || rightChild == null) return false; if(leftChild.val != rightChild.val) return false; return LR(leftChild.left,rightChild.right)&amp;&amp;LR(leftChild.right,rightChild.left); } } 面试题55 - I. 二叉树的深度题目链接：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/ 思路：本题可以使用递归的方法解决。二叉树的深度就是左右子树最大深度 + 1。 1.递归的终止条件：root为空。 2.递归工作： 本质上是对树做后序遍历。 计算节点 root 的 左子树的深度 ，即调用 maxDepth(root.left) 计算节点 root 的 右子树的深度 ，即调用 maxDepth(root.right) 3.返回值： 返回 此树的深度 ，即 max(maxDepth(root.left), maxDepth(root.right)) + 1 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1; } } 本题进阶： 面试题55 - II. 平衡二叉树题目链接：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/ 本题思路： 后序遍历 + 剪枝 （从底至顶） 此方法为本题的最优解法，但剪枝的方法不易第一时间想到。 思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。 算法流程： recur(root) 函数： 返回值： 当节点root 左 / 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值+1（ max(left, right) + 1）； 当节点root 左 / 右子树的深度差&gt;2 ：则返回−1，代表此子树不是平衡树 。 终止条件： 当 root 为空：说明越过叶节点，因此返回高度0 ； 当左（右）子树深度为−1 ：代表此树的左（右）子树 不是平衡树，因此剪枝，直接返回 −1 ； isBalanced(root)函数： 返回值： 若 recur(root) != -1，则说明此树平衡，返回true ； 否则返回false 。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isBalanced(TreeNode root) { return recur(root) != -1; } public int recur(TreeNode root){ if(root == null) return 0; int left = recur(root.left); if(left == -1) return -1; int right = recur(root.right); if(right == -1) return -1; return Math.abs(left - right) &lt; 2 ? Math.max(left,right) + 1 : -1; } } 重建二叉树题目地址：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/ 本题是一道比较经典的题目，核心思想其实还是递归。（好像二叉树大多都是使用递归……） 我们知道前序遍历的第一个节点是根节点root，中序遍历root两边的分别是左子树和右子树，根据这一特性，我们就可以求解本题，下面给出某位大佬的解题思路（原地址请点击这里）： 题目分析： 前序遍历特点： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序，以题目示例为例：[ 3 | 9 | 20 15 7 ]中序遍历特点： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序，以题目示例为例：[ 9 | 3 | 15 20 7 ]根据题目描述输入的前序遍历和中序遍历的结果中都不含重复的数字，其表明树中每个节点值都是唯一的。 根据以上特点，可以按顺序完成以下工作： 前序遍历的首个元素即为根节点 root 的值； 在中序遍历中搜索根节点 root 的索引 ，可将中序遍历划分为[ 左子树 | 根节点 | 右子树 ]。 根据中序遍历中的左（右）子树的节点数量，可将前序遍历划分为 [ 根节点 | 左子树 | 右子树 ]。 自此可确定 三个节点的关系 ：1.树的根节点、2.左子树根节点、3.右子树根节点（即前序遍历中左（右）子树的首个元素）。 子树特点： 子树的前序和中序遍历仍符合以上特点，以题目示例的右子树为例：前序遍历：[20 | 15 | 7]，中序遍历 [ 15 | 20 | 7 ] 。 根据子树特点，我们可以通过同样的方法对左（右）子树进行划分，每轮可确认三个节点的关系 。此递推性质让我们联想到用 递归方法 处理。递归解析： 递推参数： 前序遍历中根节点的索引pre_root、中序遍历左边界in_left、中序遍历右边界in_right。终止条件： 当in_left&gt;in_right，子树中序遍历为空，说明已经越过叶子节点，此时返回 null 。递推工作：建立根节点root： 值为前序遍历中索引为pre_root的节点值。搜索根节点root在中序遍历的索引i： 为了提升搜索效率，本题解使用哈希表 dic 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)。构建根节点root的左子树和右子树： 通过调用 recur()方法开启下一层递归。左子树： 根节点索引为pre_root + 1 ，中序遍历的左右边界分别为in_left 和i - 1。右子树： 根节点索引为i - in_left + pre_root + 1（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 i + 1 和in_right。返回值： 返回 root，含义是当前递归层级建立的根节点 root为上一递归层级的根节点的左或右子节点。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { HashMap&lt;Integer, Integer> map = new HashMap&lt;>(); int[] preorder; public TreeNode buildTree(int[] preorder, int[] inorder) { this.preorder = preorder; for(int i = 0;i &lt; inorder.length;++i){ map.put(inorder[i],i); } return recur(0,0,inorder.length -1); } TreeNode recur(int pre_root, int in_left, int in_right) { if(in_left > in_right) return null; TreeNode root = new TreeNode(preorder[pre_root]); int i = map.get(preorder[pre_root]); root.left = recur(pre_root + 1,in_left,i - 1); root.right = recur(pre_root + (i - 1 - in_left + 1) + 1,i + 1,in_right); return root; } } 关于上面的root.left和root.right有些朋友可能不是很理解，这里给出解释： root.left： root.right： 剑指 Offer 32 - I. 从上到下打印二叉树题目链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/ 思路： 看到按层序遍历二叉树，我们就该想到广度优先搜索（BFS），而一提到广度优先搜索，我们就可以想到用队列（Queue）来解决。 算法流程： 特例处理：当根节点为空时，返回一个空数组[]； 初始化：创建一个临时的动态数组存放val值，再创建一个带有根节点的队列； BFS循环： 终止条件：队列为空 出队：将队首元素出队，记为node 存值：将node的值存放在动态数组中 入队：若node的左右节点不为空，将node的左右节点加入到队列中（注意：由于队列是FIFO结构，题目要求从左到右打印，所以必须左节点先入队） 将动态数组的值转移到结果数组res，返回res。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int[] levelOrder(TreeNode root) { if(root == null) return new int[0]; Queue&lt;TreeNode> queue = new LinkedList&lt;>(); ArrayList&lt;Integer> tmp = new ArrayList&lt;>(); queue.offer(root); //直至队列为空时终止循环 while(queue.size() != 0){ TreeNode node = queue.poll(); tmp.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); } //将动态数组中的值转移给要返回的结果数组 int[] res = new int[tmp.size()]; for(int i = 0;i &lt; res.length;++i){ res[i] = tmp.get(i); } return res; } } 剑指 Offer 32 - II. 从上到下打印二叉树 II题目链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/ 思路： 这一题与上一题只有很微小的差别，个人觉得这一题还比较难一些，然而它却是简单难度的题目😀。废话少说，我们开始这一题的解析： 这一题与上一题最大的不同就是我们需要把每一层单独打印出来，返回的结果是嵌套的List，然而思路是不会变的，我们依旧使用队列解决。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;List&lt;Integer>> levelOrder(TreeNode root) { Queue&lt;TreeNode> queue = new LinkedList&lt;>(); List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); if(root != null) queue.offer(root); while(queue.size() != 0){ List&lt;Integer> tmp = new ArrayList&lt;>(); //这里因为queue.size()是变化的，所以我们采用递减的方法 for(int i = queue.size(); i > 0; i--){ TreeNode node = queue.poll(); tmp.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); } res.add(tmp); } return res; } } 剑指 Offer 32 - III. 从上到下打印二叉树 III题目链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/ 思路： 本题目在上一题的基础上又增加了奇偶层打印次序的问题，我们可以使用一个双端队列，奇数层插入尾部，偶数层时插入头部。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;List&lt;Integer>> levelOrder(TreeNode root) { Queue&lt;TreeNode> queue = new LinkedList&lt;>(); List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); if(root != null) queue.offer(root); while(queue.size() != 0){ //模拟双端队列 LinkedList&lt;Integer> tmp = new LinkedList&lt;>(); for(int i = queue.size();i > 0;--i){ TreeNode node = queue.poll(); //这里res.size()初始为0，所以在打印第二层时res.size()为1，第三层时res.size()为2，依此类推 if(res.size() % 2 == 0){ tmp.addLast(node.val); }else{ tmp.addFirst(node.val); } if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); } res.add(tmp); } return res; } } 2020-12-12更新： 由于本题有的Oj要求返回List&lt;&gt;，有的Oj要求返回ArrayList&lt;&gt;，故上述方法适用性不强，下面是一个能同时适用这两种情况的题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;List&lt;Integer>> levelOrder(TreeNode root) { List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); Queue&lt;TreeNode> queue = new LinkedList&lt;>(); if(root != null) { queue.offer(root); } boolean reverse = false; while(!queue.isEmpty()) { List&lt;Integer> ans = new ArrayList&lt;>(); for(int i = queue.size(); i > 0; i--) { TreeNode node = queue.poll(); if(!reverse) { ans.add(node.val); }else { ans.add(0, node.val); } if(node.left != null) { queue.offer(node.left); } if(node.right != null) { queue.offer(node.right); } } reverse = !reverse; res.add(ans); } return res; } } 199. 二叉树的右视图题目链接：https://leetcode-cn.com/problems/binary-tree-right-side-view/ BFS思路： 利用 BFS 进行层次遍历，记录下每层的最后一个元素。 时间复杂度： O(N)，每个节点都入队出队了 1 次。空间复杂度： O(N)，使用了额外的队列空间。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&lt;Integer> rightSideView(TreeNode root) { List&lt;Integer> res = new ArrayList&lt;>(); Queue&lt;TreeNode> queue = new LinkedList&lt;>(); if(root == null) return res; queue.offer(root); while(queue.size() != 0){ int length = queue.size(); for(int i = 0;i &lt; length;++i){ TreeNode node = queue.poll(); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); if(i == length - 1) res.add(node.val); } } return res; } } DFS思路： 我们按照 「根结点 -&gt; 右子树 -&gt; 左子树」的顺序访问，就可以保证每层都是最先访问最右边的节点的。 （与先序遍历 「根结点 -&gt; 左子树 -&gt; 右子树」 正好相反，先序遍历每层最先访问的是最左边的节点） 时间复杂度： O(N)，每个节点都访问了 1 次。空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN , 最坏的情况下会退化成一条链表，深度就是 N ，因此递归时使用的栈空间是 O(N) 的。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { List&lt;Integer> res = new ArrayList&lt;>(); public List&lt;Integer> rightSideView(TreeNode root) { dfs(root, 0); // 从根节点开始访问，根节点深度是0 return res; } private void dfs(TreeNode root, int depth) { if (root == null) { return; } // 先访问 当前节点，再递归地访问 右子树 和 左子树。 if (depth == res.size()) { // 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。 res.add(root.val); } depth++; dfs(root.right, depth); dfs(root.left, depth); } } 二叉树的最近公共祖先题目链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ 本题解析请看这里 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null &amp;&amp; right == null) return null; if(left == null) return right; if(right == null) return left; return root; } } 验证二叉搜索树题目链接：https://leetcode-cn.com/problems/validate-binary-search-tree/ 思路： 本题为验证二叉搜索树（BST），那么我们应该联想到二叉搜索树的特性，那就是： 若它的左子树不为空，那么左子树上所有节点的 key 都小于根节点的 key。 若它的右子树不为空，那么右子树上所有节点的 key 都大于根节点的 key。 它的左右子树也分别为二叉搜索树。 发现了吗，BST 的节点大小顺序为：left &lt; root &lt; right。 利用这一特性，很自然的我们就会想到 BST 的中序遍历其实就是一个递增的序列。 那么我们该如何验证某棵树是不是 BST，采用中序遍历，只需要看当前节点是否大于已经遍历的上一个节点就行了。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { long pre = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if(root == null) return true; if(!isValidBST(root.left)) return false; if(root.val &lt;= pre) return false; pre = root.val; return isValidBST(root.right); } } 总结：在我们看到二叉搜索树\\这几个字的时候，脑子里应该自然想到它的几个特点： 节点值大小顺序：left &lt; root &lt; right； 二叉搜索树的中序遍历的结果是递增的。 将有序数组转换为二叉搜索树题目链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ 这一题不算太难，但结合了二分查找的一些特性，所以单独拿出来讲讲。 题目描述： 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 我们知道二叉搜索树的中序遍历结果正是一个按照升序排列的序列，那么这一题的意思显然就是让我们由一个按照升序排列的有序数组还原出一个二叉搜索树，因此我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树。又因为本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点。这就又结合了上面提到的二分查找的特性了，即不断地找中间元素作为根节点。 题解： /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { return recur(nums, 0, nums.length - 1); } public TreeNode recur(int[] nums, int lo, int hi){ if(lo > hi) return null; int mid = (lo + hi)/2; TreeNode root = new TreeNode(nums[mid]); root.left = recur(nums, lo, mid - 1); root.right = recur(nums, mid + 1, hi); return root; } }","link":"/2020/10/02/leetcode-shua-ti-hui-zong-bu-zai-geng-xin/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"SSM","slug":"SSM","link":"/tags/SSM/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Bug","slug":"Bug","link":"/categories/Bug/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"SSM","slug":"SSM","link":"/categories/SSM/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}